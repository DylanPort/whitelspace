<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
  <title>Whistle — P2P encrypted tips + Solana memo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Ensure Buffer exists before Solana Web3 (fixes Buffer issues in browser) -->
  <script>window.global = window.global || window;</script>
  <script type="module">import { Buffer } from 'https://esm.sh/buffer@6.0.3'; window.Buffer = Buffer;</script>
  <script crossorigin src="https://unpkg.com/@solana/web3.js@1.95.3/lib/index.iife.min.js"></script>
<style>
    html,body{height:100%}
    body{background:#0b0f14}
    /* Premium dynamic visuals */
    @keyframes gradientMove{0%{transform:translate3d(-6%, -4%, 0) scale(1)}100%{transform:translate3d(6%, 4%, 0) scale(1.08)}}
    @keyframes floatSlow{0%{transform:translateY(0)}50%{transform:translateY(-4px)}100%{transform:translateY(0)}}
    @keyframes ripple{0%{transform:scale(0);opacity:.5}100%{transform:scale(4);opacity:0}}
    @keyframes toastIn{0%{transform:translateY(8px);opacity:0}100%{transform:translateY(0);opacity:1}}
    .bg-anim{animation:gradientMove 14s ease-in-out infinite alternate}
    .float-slow{animation:floatSlow 6s ease-in-out infinite}
    .glass-hover{transition:transform .3s ease, box-shadow .3s ease}
    .glass-hover:hover{transform:translateY(-2px);box-shadow:0 20px 40px rgba(0,0,0,.35)}
    .btn-ripple{position:relative;overflow:hidden}
    .btn-ripple span.ripple{position:absolute;border-radius:9999px;background:rgba(255,255,255,.35);transform:scale(0);animation:ripple .6s linear;pointer-events:none}
    .toast-enter{animation:toastIn .25s ease-out}

     /* Animated sky with clouds */
     .sky{position:fixed;inset:0;pointer-events:none;z-index:-9;background:linear-gradient(180deg,#7ec8ff 0%, #bfe4ff 45%, #e8f4ff 100%)}
     .cloud{position:absolute;filter:blur(0px);opacity:.95}
    .cloud::before{content:"";position:absolute;inset:0; background:
      radial-gradient(120px 70px at 60px 60px, rgba(255,255,255,.95) 40%, rgba(255,255,255,0) 60%),
      radial-gradient(100px 60px at 120px 60px, rgba(255,255,255,.95) 40%, rgba(255,255,255,0) 60%),
      radial-gradient(140px 80px at 180px 70px, rgba(255,255,255,.95) 40%, rgba(255,255,255,0) 60%),
      radial-gradient(110px 65px at 110px 90px, rgba(255,255,255,.95) 40%, rgba(255,255,255,0) 60%);
    }
    @keyframes cloudDrift{from{transform:translateX(-35%)}to{transform:translateX(135%)}}
    .c1{top:12%;left:-30%;width:420px;height:160px;animation:cloudDrift 55s linear infinite}
    .c2{top:28%;left:-40%;width:520px;height:190px;animation:cloudDrift 85s linear infinite}
    .c3{top:42%;left:-35%;width:360px;height:140px;animation:cloudDrift 60s linear infinite}
    .c4{top:58%;left:-45%;width:620px;height:200px;animation:cloudDrift 95s linear infinite}
    .c5{top:70%;left:-38%;width:380px;height:140px;animation:cloudDrift 70s linear infinite}
    .c6{top:18%;left:-48%;width:300px;height:120px;animation:cloudDrift 72s linear infinite}
    .c7{top:35%;left:-52%;width:260px;height:110px;animation:cloudDrift 66s linear infinite}
    .c8{top:64%;left:-50%;width:440px;height:170px;animation:cloudDrift 88s linear infinite}
    .c9{top:78%;left:-46%;width:300px;height:120px;animation:cloudDrift 76s linear infinite}

    /* Dim overlay to ensure text contrast */
    .sky-dim{position:fixed;inset:0;pointer-events:none;z-index:-8;background:linear-gradient(180deg,rgba(0,0,0,.38) 0%, rgba(0,0,0,.32) 35%, rgba(0,0,0,.28) 65%, rgba(0,0,0,.36) 100%)}

    /* Stronger glass panels for readability */
    .glass-strong{background:rgba(10,14,20,.58)!important;border-color:rgba(255,255,255,.12)!important;box-shadow:0 24px 60px rgba(0,0,0,.45)!important}
    .panel-strong{background:rgba(10,14,20,.58)!important;border-color:rgba(255,255,255,.12)!important}

    /* Home: premium animations */
    @keyframes fadeUp{0%{opacity:0;transform:translateY(12px)}100%{opacity:1;transform:translateY(0)}}
    @keyframes slideInLeft{0%{opacity:0;transform:translateX(-20px)}100%{opacity:1;transform:translateX(0)}}
    @keyframes slideInRight{0%{opacity:0;transform:translateX(20px)}100%{opacity:1;transform:translateX(0)}}
    @keyframes scaleIn{0%{opacity:0;transform:scale(.94)}100%{opacity:1;transform:scale(1)}}
    @keyframes shimmer{0%{background-position:200% center}100%{background-position:-200% center}}
    @keyframes pulse{0%,100%{opacity:1}50%{opacity:.6}}
    @keyframes bounce{0%,100%{transform:translateY(0)}50%{transform:translateY(-6px)}}
    @keyframes rotate{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}
    @keyframes glow{0%,100%{box-shadow:0 0 20px rgba(103,232,249,.3)}50%{box-shadow:0 0 40px rgba(103,232,249,.6),0 0 60px rgba(167,139,250,.4)}}
    
    .fade-up{animation:fadeUp .5s ease-out both}
    .fade-up-2{animation:fadeUp .6s ease-out .05s both}
    .fade-up-3{animation:fadeUp .6s ease-out .1s both}
    .slide-in-left{animation:slideInLeft .5s ease-out both}
    .slide-in-right{animation:slideInRight .5s ease-out both}
    .scale-in{animation:scaleIn .4s cubic-bezier(.34,1.56,.64,1) both}
    
    .hover-lift{transition:transform .25s ease, box-shadow .25s ease}
    .hover-lift:hover{transform:translateY(-3px) scale(1.01);box-shadow:0 18px 40px rgba(0,0,0,.45)}
    
    .badge-step{display:inline-flex;align-items:center;justify-content:center;width:22px;height:22px;border-radius:9999px;background:linear-gradient(135deg,#67e8f9,#a78bfa);color:#0b0f14;font-weight:700;font-size:12px;margin-right:8px;animation:glow 3s ease-in-out infinite}
    
    .step-card{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.10);border-radius:16px;padding:10px;transition:all .3s ease}
    .step-card:hover{background:rgba(255,255,255,.06);border-color:rgba(103,232,249,.2)}
    
    .mini-code{background:rgba(0,0,0,.45);border:1px solid rgba(255,255,255,.12);border-radius:8px;padding:8px;transition:all .3s ease}
    .mini-code:hover{border-color:rgba(103,232,249,.3);box-shadow:0 0 20px rgba(103,232,249,.15)}
    
    .shimmer-bg{background:linear-gradient(90deg,rgba(255,255,255,0) 0%,rgba(255,255,255,.08) 50%,rgba(255,255,255,0) 100%);background-size:200% 100%;animation:shimmer 3s linear infinite}
    
    .pulse-glow{animation:pulse 2s ease-in-out infinite}
    
    .bounce-slow{animation:bounce 3s ease-in-out infinite}
    
    .rotate-slow{animation:rotate 20s linear infinite}
    
    /* Progress bar animations */
    @keyframes progressShine{0%{background-position:-100% 0}100%{background-position:200% 0}}
    .progress-shine{background:linear-gradient(90deg,#67e8f9 0%,#a78bfa 50%,#67e8f9 100%);background-size:200% 100%;animation:progressShine 2s linear infinite}
    
    /* Button press effect */
    .btn-press{transition:all .15s ease}
    .btn-press:active{transform:scale(.96)}
    
    /* Card entrance stagger */
    .stagger-1{animation-delay:.05s}
    .stagger-2{animation-delay:.1s}
    .stagger-3{animation-delay:.15s}
    .stagger-4{animation-delay:.2s}
</style>
  <link rel="preconnect" href="https://unpkg.com">
  <link rel="preconnect" href="https://cdn.tailwindcss.com">
  <link rel="icon" type="image/png" href="whistel_logo_top_right_2048.png">
  <!-- Lucide Icons -->
  <script src="https://unpkg.com/lucide@latest"></script>
  <!-- EXIF Reader for metadata scrubbing -->
  <script src="https://cdn.jsdelivr.net/npm/exifreader@4.14.1/dist/exif-reader.js"></script>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState } = React;
    // Project constants
    const CONTRACT_ADDRESS = '6Hb2xgEhyN9iVVH3cgSxYjfN774ExzgiCftwiWdjpump';

    // ---------- small helpers ----------
    const enc = new TextEncoder();
    const dec = new TextDecoder();
    const hex = (b) => Array.from(b).map((x) => x.toString(16).padStart(2, "0")).join("");
    // robust base64 helpers (URL-safe tolerant + large arrays)
    function safeAtob(str){
      let s = String(str||'');
      s = s.replace(/\s+/g,'').replace(/-/g,'+').replace(/_/g,'/');
      while (s.length % 4) s += '=';
      return atob(s);
    }
    function b64(u8){
      let binary = '';
      const CHUNK = 0x8000;
      for (let i=0;i<u8.length;i+=CHUNK){
        const sub = u8.subarray(i, i+CHUNK);
        binary += String.fromCharCode.apply(null, sub);
      }
      return btoa(binary);
    }
    function ub64(s){
      const bin = safeAtob(s);
      const out = new Uint8Array(bin.length);
      for (let i=0;i<bin.length;i++) out[i] = bin.charCodeAt(i);
      return out;
    }
    function textToB64(str){ return b64(new TextEncoder().encode(str)); }
    function b64ToText(s){ return new TextDecoder().decode(ub64(s)); }

    // Ensure Buffer polyfill for web3 internals in browser
    async function ensureBuffer(){
      if (!window.Buffer){
        try{
          const m = await import('https://esm.sh/buffer@6.0.3?bundle');
          window.Buffer = m.Buffer;
        }catch(e){ /* ignore; some environments already polyfill */ }
      }
    }

    // RPC defaults (hidden in UI; configurable via localStorage keys rpcHttpUrl / rpcWsUrl)
    const DEFAULT_RPC_HTTP = 'https://rpc-mainnet.solanatracker.io/?api_key=4f442388-ae6f-41ba-a9c4-30d3ff2ee2a0';
    const DEFAULT_RPC_WS   = 'wss://rpc-mainnet.solanatracker.io/?api_key=4f442388-ae6f-41ba-a9c4-30d3ff2ee2a0';
    function getRpcUrls(){
      try{
        const http = (localStorage.getItem('rpcHttpUrl') || DEFAULT_RPC_HTTP).trim();
        const ws = (localStorage.getItem('rpcWsUrl') || '').trim();
        return { http, ws };
      }catch{ return { http: DEFAULT_RPC_HTTP, ws: '' }; }
    }

    // Short, domain-like code for hashes (Base32 RFC4648, lowercase, dotted groups)
    function toBase32(u8){
      const alphabet = 'abcdefghijklmnopqrstuvwxyz234567';
      let out = '';
      let bits = 0, value = 0;
      for (let i=0;i<u8.length;i++){
        value = (value << 8) | u8[i];
        bits += 8;
        while (bits >= 5){
          out += alphabet[(value >>> (bits - 5)) & 31];
          bits -= 5;
        }
      }
      if (bits > 0){ out += alphabet[(value << (5 - bits)) & 31]; }
      return out;
    }
    function fromBase32(str){
      const alphabet = 'abcdefghijklmnopqrstuvwxyz234567';
      const map = Object.create(null);
      for (let i=0;i<alphabet.length;i++){ map[alphabet[i]] = i; }
      let bits = 0, value = 0, out = [];
      for (const ch of str.toLowerCase()){
        if (!(ch in map)) throw new Error('invalid base32');
        value = (value << 5) | map[ch];
        bits += 5;
        if (bits >= 8){
          out.push((value >>> (bits - 8)) & 255);
          bits -= 8;
        }
      }
      return new Uint8Array(out);
    }
    function formatShortCode(bytes){
      const b32 = toBase32(bytes).toLowerCase();
      return 'whis.' + b32.match(/.{1,4}/g).join('.');
    }
    function parseHashOrCode(input){
      const t = (input||'').trim().toLowerCase();
      if (/^[0-9a-f]{64}$/.test(t)) return t; // hex
      const clean = t.replace(/^whis\./,'').replace(/\./g,'');
      if (/^[a-z2-7]+$/.test(clean)){
        const bytes = fromBase32(clean);
        return hex(bytes);
      }
      throw new Error('Enter 64-hex or a whis.xxxx short code');
    }

    async function sha256(bytes) {
      const h = await crypto.subtle.digest("SHA-256", bytes);
      return new Uint8Array(h);
    }

    // ---------- persistence helpers ----------
    function usePersistentState(key, defaultValue){
      const [value, setValue] = React.useState(() => {
        try{
          const raw = localStorage.getItem(key);
          return raw != null ? JSON.parse(raw) : defaultValue;
        }catch{ return defaultValue; }
      });
      React.useEffect(()=>{
        try{ localStorage.setItem(key, JSON.stringify(value)); }catch{}
      }, [key, value]);
      return [value, setValue];
    }

    const HISTORY_KEY = 'whistleHistory';
    const HISTORY_MAX = 50;
    function storageGetHistory(){
      try{ return JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]'); }catch{ return []; }
    }
    function storageSetHistory(list){
      try{ localStorage.setItem(HISTORY_KEY, JSON.stringify(list)); }catch{}
    }
    function storagePushHistory(entry){
      const list = storageGetHistory();
      list.unshift({ id: Math.random().toString(36).slice(2), ...entry });
      while (list.length > HISTORY_MAX) list.pop();
      storageSetHistory(list);
      try{ window.dispatchEvent(new CustomEvent('whHistory')); }catch{}
    }

    async function packBundle(text, files) {
      const pkg = { v: 1, createdAt: new Date().toISOString(), text, files: [] };
      let total = 0;
      for (const f of files) {
        const buf = new Uint8Array(await f.arrayBuffer());
        total += buf.length;
        if (total > 5 * 1024 * 1024 * 1024) throw new Error("Total evidence > 5 GB");
        pkg.files.push({ name: f.name, type: f.type, size: f.size, b64: b64(buf) });
      }
      const payload = enc.encode(JSON.stringify(pkg));
      const aesKeyRaw = crypto.getRandomValues(new Uint8Array(32));
      const aesKey = await crypto.subtle.importKey("raw", aesKeyRaw, "AES-GCM", false, ["encrypt", "decrypt"]);
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const ct = new Uint8Array(await crypto.subtle.encrypt({ name: "AES-GCM", iv }, aesKey, payload));
      return { pkgBytes: payload, aesKeyRaw, iv, ct };
    }

    async function unpackBundle(aesKeyRaw, iv, ct) {
      const aesKey = await crypto.subtle.importKey("raw", aesKeyRaw, "AES-GCM", false, ["decrypt"]);
      const plain = new Uint8Array(await crypto.subtle.decrypt({ name: "AES-GCM", iv }, aesKey, ct));
      return JSON.parse(dec.decode(plain));
    }

    function useToasts() {
      const [toasts, setToasts] = useState([]);
      function push(msg, tone = "default") {
        const id = Math.random().toString(36).slice(2);
        setToasts((t) => [...t, { id, msg, tone }]);
        setTimeout(() => setToasts((t) => t.filter((x) => x.id !== id)), 2800);
      }
      return { toasts, push };
    }

    // micro interaction: ripple on buttons
    function ripple(e){
      try{
        const btn = e.currentTarget;
        const rect = btn.getBoundingClientRect();
        const size = Math.max(rect.width, rect.height);
        const x = e.clientX - rect.left - size/2;
        const y = e.clientY - rect.top - size/2;
        const circle = document.createElement('span');
        circle.className = 'ripple';
        circle.style.width = circle.style.height = size + 'px';
        circle.style.left = x + 'px';
        circle.style.top = y + 'px';
        btn.appendChild(circle);
        setTimeout(()=>{ try{ circle.remove(); }catch{} }, 650);
      }catch{}
    }

    // ============ PRIVACY FEATURES ============
    
    // ===== STEGANOGRAPHY MODE =====
    // Hide encrypted data inside an innocent-looking image
    async function hideDataInImage(imageFile, secretText) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        const reader = new FileReader();
        
        reader.onload = (e) => {
          img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Convert secret to binary
            const secretBinary = secretText.split('').map(c => 
              c.charCodeAt(0).toString(2).padStart(8, '0')
            ).join('');
            
            // Add length prefix (32 bits)
            const lengthBinary = secretBinary.length.toString(2).padStart(32, '0');
            const fullBinary = lengthBinary + secretBinary;
            
            // Check if image has enough capacity
            if (fullBinary.length > data.length / 4) {
              reject(new Error('Image too small for this message'));
              return;
            }
            
            // Hide data in LSB of red channel
            for (let i = 0; i < fullBinary.length; i++) {
              data[i * 4] = (data[i * 4] & 0xFE) | parseInt(fullBinary[i]);
            }
            
            ctx.putImageData(imageData, 0, 0);
            canvas.toBlob((blob) => {
              resolve(new File([blob], 'photo.png', { type: 'image/png' }));
            }, 'image/png', 1.0);
          };
          img.src = e.target.result;
        };
        
        reader.onerror = reject;
        reader.readAsDataURL(imageFile);
      });
    }
    
    async function extractDataFromImage(imageFile) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        const reader = new FileReader();
        
        reader.onload = (e) => {
          img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Extract length (first 32 bits)
            let lengthBinary = '';
            for (let i = 0; i < 32; i++) {
              lengthBinary += (data[i * 4] & 1).toString();
            }
            const length = parseInt(lengthBinary, 2);
            
            if (length <= 0 || length > data.length * 4) {
              reject(new Error('No hidden data found or corrupted'));
              return;
            }
            
            // Extract secret data
            let secretBinary = '';
            for (let i = 32; i < 32 + length; i++) {
              secretBinary += (data[i * 4] & 1).toString();
            }
            
            // Convert binary back to text
            let secret = '';
            for (let i = 0; i < secretBinary.length; i += 8) {
              const byte = secretBinary.substr(i, 8);
              secret += String.fromCharCode(parseInt(byte, 2));
            }
            
            resolve(secret);
          };
          img.src = e.target.result;
        };
        
        reader.onerror = reject;
        reader.readAsDataURL(imageFile);
      });
    }

    // 1. Metadata Scrubber - Remove EXIF and metadata from files
    async function scrubMetadata(file) {
      try {
        // For images - remove EXIF data
        if (file.type.startsWith('image/')) {
          const arrayBuffer = await file.arrayBuffer();
          const uint8Array = new Uint8Array(arrayBuffer);
          
          // Create a canvas to re-encode without metadata
          const img = new Image();
          const blob = new Blob([uint8Array], { type: file.type });
          const url = URL.createObjectURL(blob);
          
          return new Promise((resolve) => {
            img.onload = () => {
              const canvas = document.createElement('canvas');
              canvas.width = img.width;
              canvas.height = img.height;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0);
              
              canvas.toBlob((cleanBlob) => {
                URL.revokeObjectURL(url);
                resolve(new File([cleanBlob], file.name, { type: file.type }));
              }, file.type, 0.95);
            };
            img.src = url;
          });
        }
        
        // For PDFs and other files - strip metadata headers
        if (file.type === 'application/pdf') {
          // Basic PDF metadata removal (simplified)
          const arrayBuffer = await file.arrayBuffer();
          const uint8Array = new Uint8Array(arrayBuffer);
          // Return as-is with warning (full PDF scrubbing requires pdf-lib)
          return file;
        }
        
        // For other files, return as-is
        return file;
      } catch (e) {
        console.error('Metadata scrub failed:', e);
        return file; // Return original if scrubbing fails
      }
    }


    function GlassCard({ title, subtitle, children, className = "" }) {
      const ref = useRef(null);
      const [tilt, setTilt] = useState('');
      function onMove(e){
        const el = ref.current; if(!el) return;
        const r = el.getBoundingClientRect();
        const px = (e.clientX - r.left) / r.width; // 0..1
        const py = (e.clientY - r.top) / r.height; // 0..1
        const rx = (py - .5) * 6; // tilt X
        const ry = (px - .5) * -6; // tilt Y
        setTilt(`perspective(900px) rotateX(${rx}deg) rotateY(${ry}deg)`);
      }
      function onLeave(){ setTilt(''); }
      return (
        <section ref={ref} onMouseMove={onMove} onMouseLeave={onLeave}
          className={`relative rounded-2xl border border-white/10 backdrop-blur-xl p-5 shadow-xl shadow-black/30 glass-hover will-change-transform ${className} glass-strong`}
          style={{ transform: tilt }}>
          <div className="mb-3">
            <h3 className="text-lg font-semibold text-white/90">{title}</h3>
            {subtitle && <p className="text-xs text-white/50">{subtitle}</p>}
  </div>
          {children}
        </section>
      );
    }

    function SectionHeader() {
      return (
        <header className="flex items-center justify-between border-b border-white/10 pb-3 fade-up">
          <div className="flex items-center gap-3">
            <div className="relative h-9 w-9 rounded-xl overflow-hidden border border-white/20 float-slow bg-white/5 hover:scale-110 transition-transform">
              <img src="whistel_logo_top_right_2048.png" alt="Whistle" className="absolute inset-0 h-full w-full object-contain"/>
               {!walletStore.pubkey && <span className="absolute inset-0 rounded-xl bg-cyan-400/20 animate-ping pulse-glow" />}
    </div>
      <div>
              <div className="text-white font-semibold">Whistle</div>
              <div className="text-xs text-white/50">P2P encrypted tips • Solana proof</div>
              <div className="mt-1 flex items-center gap-2 text-[11px] text-white/60">
                <span className="font-mono truncate max-w-[42ch]" title={CONTRACT_ADDRESS}>{CONTRACT_ADDRESS}</span>
                <button onClick={async()=>{ try{ await navigator.clipboard.writeText(CONTRACT_ADDRESS); alert('CA copied'); }catch{} }} className="rounded-md bg-white/10 hover:bg-white/20 border border-white/10 px-2 py-[2px] text-white/80 btn-press">Copy</button>
      </div>
      </div>
    </div>
          <WalletConnectButton />
</header>
      );
    }

    // simple wallet event store
    const walletStore = { pubkey: null, setPub: () => {} };

    function WalletConnectButton() {
      const [label, setLabel] = useState("Connect Phantom");
      useEffect(() => {
        walletStore.setPub = (pk) => setLabel(pk ? `Connected: ${pk.slice(0, 4)}…` : "Connect Phantom");
      }, []);
      return (
        <button
          className="rounded-xl bg-cyan-500/80 hover:bg-cyan-400 text-black font-semibold px-4 py-2 transition-colors btn-ripple active:scale-[.98]"
          onClick={async (e) => {
            ripple(e);
            if (!window?.solana?.isPhantom) {
              alert("Install Phantom to post Solana Memo (optional). Other features work without it.");
              return;
            }
            try {
              const r = await window.solana.connect();
              walletStore.pubkey = r.publicKey.toBase58();
              walletStore.setPub(walletStore.pubkey);
            } catch (e) {}
          }}
        >
          {label}
        </button>
      );
    }

    function StepPills({ step, setStep }) {
      const tabs = [
        { id: "home", label: "Home" },
        { id: "receive", label: "Receiver" },
        { id: "send", label: "Sender" },
        { id: "stego-send", label: "🎭 Stego Send" },
        { id: "stego-receive", label: "🎭 Stego Receive" },
      ];
      return (
        <div className="flex flex-wrap gap-2 md:hidden">
          {tabs.map((t) => (
            <button
              key={t.id}
              onClick={() => setStep(t.id)}
              className={`rounded-full px-4 py-2 text-sm border ${
                step === t.id
                  ? "border-cyan-400 bg-cyan-400/20 text-cyan-200"
                  : "border-white/10 bg-white/[0.03] text-white/70 hover:bg-white/[0.06]"
              }`}
            >
              {t.label}
            </button>
          ))}
      </div>
      );
    }

    // Sidebar navigation
    function Sidebar({ step, setStep }){
      const items = [
        { id:'home',    label:'Home', icon:'home' },
        { id:'send',    label:'Sender', icon:'send' },
        { id:'receive', label:'Receiver', icon:'download' },
        { id:'stego-send', label:'🎭 Stego Sender', icon:'image' },
        { id:'stego-receive', label:'🎭 Stego Receiver', icon:'scan' },
      ];
      
      useEffect(()=>{
        if(window.lucide) window.lucide.createIcons();
      },[step]);
      
      return (
        <aside className="hidden md:block w-[260px] shrink-0 scale-in">
          <div className="rounded-3xl border border-white/10 p-4 sticky top-4 panel-strong">
            <nav className="space-y-2">
              {items.map((x,i)=> (
                <button key={x.id} onClick={()=>setStep(x.id)}
                  className={`w-full flex items-center gap-3 rounded-xl px-3 py-3 border text-sm transition-all btn-press ${step===x.id
                    ? 'border-cyan-400/60 bg-cyan-400/15 text-cyan-100 scale-in'
                    : 'border-white/10 bg-white/[0.03] text-white/80 hover:bg-white/[0.07] hover:scale-[1.02]'}
                  stagger-${i+1}`}>
                  <i data-lucide={x.icon} className="w-5 h-5"></i>
                  {x.label}
                </button>
              ))}
            </nav>
      </div>
        </aside>
      );
    }

    // Home landing
    function Home({ setStep }){
      useEffect(()=>{
        if(window.lucide) window.lucide.createIcons();
      },[]);
      
      return (
        <div className="space-y-4">
          <div className="fade-up">
            <GlassCard title="Welcome to Whistle" subtitle="Private, peer‑to‑peer tips with on‑chain proof">
              <p className="text-white/70 text-sm">Two roles. One secure hand‑off. Stream the encrypted bundle directly from sender to receiver. Only the bundle hash is posted to Solana as public proof.</p>
            </GlassCard>
    </div>
          <div className="grid lg:grid-cols-2 gap-4 fade-up-2">
            <div className="step-card hover-lift slide-in-left">
              <div className="flex items-center gap-2 text-gray-900 font-semibold mb-3">
                <div className="flex items-center justify-center w-10 h-10 rounded-xl bg-gradient-to-br from-cyan-400 to-cyan-600">
                  <i data-lucide="send" className="w-6 h-6 text-white"></i>
                </div>
                <span>Sender — real example</span>
              </div>
              <ul className="text-sm text-gray-800 space-y-1 list-disc list-inside">
                <li>Write: "Evidence of bid‑rigging in Q3." Attach <em>report.pdf</em> and <em>video.mp4</em>.</li>
                <li>Click <strong>Generate Offer</strong> → share Offer with the receiver.</li>
                <li>Paste their Answer → <strong>Connect</strong> → <strong>Send</strong>.</li>
                <li>App posts memo with hash, e.g. <span className="font-mono">whis.4f2c.abcd…</span></li>
              </ul>
              <div className="mt-2">
                <div className="mini-code font-mono text-xs text-gray-700 shimmer-bg">OFFER: eyJ0eXAiOiJ... (copy, paste to receiver)</div>
              </div>
              <div className="mt-3">
                <button onClick={()=>setStep('send')} className="flex items-center gap-2 rounded-xl bg-cyan-500/80 hover:bg-cyan-400 text-black font-semibold px-4 py-2 btn-press">
                  <i data-lucide="arrow-right" className="w-5 h-5"></i>
                  Start as Sender
                </button>
              </div>
            </div>
            <div className="step-card hover-lift slide-in-right">
              <div className="flex items-center gap-2 text-gray-900 font-semibold mb-3">
                <div className="flex items-center justify-center w-10 h-10 rounded-xl bg-gradient-to-br from-purple-400 to-purple-600">
                  <i data-lucide="download" className="w-6 h-6 text-white"></i>
                </div>
                <span>Receiver — real example</span>
              </div>
              <ul className="text-sm text-gray-800 space-y-1 list-disc list-inside">
                <li>Paste Offer → click <strong>Generate Answer</strong> → send it back.</li>
                <li>When connected, the encrypted bundle streams; it decrypts locally.</li>
                <li>Download <em>report.pdf</em>, preview <em>video.mp4</em>, view the computed hash.</li>
                <li>Optionally post your own memo with the same hash.</li>
              </ul>
              <div className="mt-2">
                <div className="mini-code font-mono text-xs text-gray-700 shimmer-bg">ANSWER: eyJhbGciOiJ... (copy, send back to sender)</div>
              </div>
              <div className="mt-3">
                <button onClick={()=>setStep('receive')} className="flex items-center gap-2 rounded-xl bg-white/15 hover:bg-white/25 text-gray-900 font-semibold px-4 py-2 border border-white/10 btn-press">
                  <i data-lucide="arrow-right" className="w-5 h-5"></i>
                  Start as Receiver
                </button>
              </div>
            </div>
          </div>
          <div className="fade-up-3">
            <GlassCard title="Why it's safe" subtitle="Short & direct">
              <div className="grid md:grid-cols-3 gap-3 text-sm text-white/80">
                <div className="step-card scale-in stagger-1 flex items-center gap-2">
                  <i data-lucide="lock" className="w-5 h-5 text-cyan-400"></i>
                  <span>End‑to‑end: AES‑GCM payload, RSA‑OAEP key wrapping.</span>
                </div>
                <div className="step-card scale-in stagger-2 flex items-center gap-2">
                  <i data-lucide="share-2" className="w-5 h-5 text-purple-400"></i>
                  <span>P2P stream: no file uploads; nothing stored server‑side.</span>
                </div>
                <div className="step-card scale-in stagger-3 flex items-center gap-2">
                  <i data-lucide="file-check" className="w-5 h-5 text-emerald-400"></i>
                  <span>Proof only: Solana memo posts just the SHA‑256 hash.</span>
                </div>
      </div>
            </GlassCard>
      </div>
    </div>
      );
    }

    function Onboarding({ setStep }) {
      const [open, setOpen] = useState(true);
      if (!open) return null;
      return (
        <div className="fixed inset-0 z-50 grid place-items-center bg-black/70 backdrop-blur">
          <div className="max-w-3xl w-[92%] rounded-3xl border border-white/10 bg-gradient-to-b from-white/[0.08] to-white/[0.03] p-6 text-white shadow-2xl">
            <h2 className="text-xl font-semibold mb-2">Choose your role to get started</h2>
            <div className="grid md:grid-cols-2 gap-4 mt-3">
              <div className="rounded-2xl border border-white/10 bg-white/[0.04] p-4">
                <h3 className="font-semibold text-white/90">Receiver</h3>
                <ul className="text-sm text-white/70 list-disc list-inside space-y-1 mt-1">
                  <li>Paste Offer</li>
                  <li>Generate Answer and send it back</li>
                  <li>Receive and decrypt tip</li>
                </ul>
                <button onClick={() => { setStep('receive'); setOpen(false); }} className="mt-3 w-full rounded-xl bg-cyan-500/80 hover:bg-cyan-400 text-black font-semibold px-4 py-2">I'm the Receiver</button>
    </div>
              <div className="rounded-2xl border border-white/10 bg-white/[0.04] p-4">
                <h3 className="font-semibold text-white/90">Sender</h3>
                <ul className="text-sm text-white/70 list-disc list-inside space-y-1 mt-1">
                  <li>Write tip + attach files</li>
                  <li>Generate Offer and share it</li>
                  <li>Paste Answer • Connect • Send</li>
                </ul>
                <button onClick={() => { setStep('send'); setOpen(false); }} className="mt-3 w-full rounded-xl bg-white/15 hover:bg-white/25 text-white font-semibold px-4 py-2 border border-white/10">I'm the Sender</button>
    </div>
      </div>
      </div>
    </div>
      );
    }

    // OpSec Checklist Modal
    function OpSecChecklist({ open, onClose, onConfirm }) {
      const [checks, setChecks] = useState({
        vpn: false,
        metadata: false,
        personal: false,
        tor: false
      });
      
      useEffect(()=>{
        if(window.lucide) window.lucide.createIcons();
      },[open]);
      
      if (!open) return null;
      
      const allChecked = Object.values(checks).filter(v => v).length >= 3; // At least 3 required
      
      return (
        <div className="fixed inset-0 z-50 grid place-items-center bg-black/80 backdrop-blur">
          <div className="max-w-xl w-[92%] rounded-3xl border border-white/10 bg-gradient-to-b from-white/[0.08] to-white/[0.03] p-6 text-white shadow-2xl scale-in">
            <div className="flex items-center gap-2 mb-3">
              <i data-lucide="shield-alert" className="w-6 h-6 text-yellow-400"></i>
              <h2 className="text-xl font-semibold">Security Checklist</h2>
    </div>
            <p className="text-sm text-white/70 mb-4">Before sending, confirm you've taken these privacy steps:</p>
            
            <div className="space-y-3">
              <label className="flex items-start gap-3 cursor-pointer p-3 rounded-xl hover:bg-white/5 transition">
                <input type="checkbox" checked={checks.vpn} onChange={(e)=>setChecks({...checks, vpn: e.target.checked})} className="mt-1 w-4 h-4" />
                <div className="flex-1">
                  <div className="font-semibold text-white/90">Using VPN or Tor</div>
                  <div className="text-xs text-white/60">Hide your IP address from network observers</div>
    </div>
              </label>
              
              <label className="flex items-start gap-3 cursor-pointer p-3 rounded-xl hover:bg-white/5 transition">
                <input type="checkbox" checked={checks.metadata} onChange={(e)=>setChecks({...checks, metadata: e.target.checked})} className="mt-1 w-4 h-4" />
                <div className="flex-1">
                  <div className="font-semibold text-white/90">Files have metadata removed</div>
                  <div className="text-xs text-white/60">Use the "Scrub Metadata" button above</div>
    </div>
              </label>
              
              <label className="flex items-start gap-3 cursor-pointer p-3 rounded-xl hover:bg-white/5 transition">
                <input type="checkbox" checked={checks.personal} onChange={(e)=>setChecks({...checks, personal: e.target.checked})} className="mt-1 w-4 h-4" />
                <div className="flex-1">
                  <div className="font-semibold text-white/90">No personal info in message</div>
                  <div className="text-xs text-white/60">Names, dates, locations, or unique phrases removed</div>
</div>
              </label>
              
              <label className="flex items-start gap-3 cursor-pointer p-3 rounded-xl hover:bg-white/5 transition">
                <input type="checkbox" checked={checks.tor} onChange={(e)=>setChecks({...checks, tor: e.target.checked})} className="mt-1 w-4 h-4" />
                <div className="flex-1">
                  <div className="font-semibold text-white/90">Verified receiver identity</div>
                  <div className="text-xs text-white/60">Confirm you're sending to the correct journalist/newsroom</div>
    </div>
              </label>
</div>

            <div className="flex gap-3 mt-5">
              <button onClick={onClose} className="flex-1 rounded-xl bg-white/10 hover:bg-white/15 text-white font-semibold px-4 py-2 border border-white/10 btn-press">Cancel</button>
              <button onClick={onConfirm} disabled={!allChecked} className="flex-1 rounded-xl bg-cyan-500/80 hover:bg-cyan-400 disabled:opacity-50 disabled:cursor-not-allowed text-black font-semibold px-4 py-2 btn-press">
                {allChecked ? 'Continue' : 'Check at least 3'}
              </button>
            </div>
          </div>
        </div>
      );
    }

    function Sender({ pushToast, onHashReady }) {
      const [tipText, setTipText] = usePersistentState('tipText', "");
      const fileRef = useRef(null);
      const [offerOut, setOfferOut] = useState("");
      const [answerIn, setAnswerIn] = usePersistentState('tipAnswerIn', "");
      const [connStatus, setConnStatus] = useState("Not connected");
      const [sending, setSending] = useState(false);
      const [prog, setProg] = useState(0);
      const peerRef = useRef(null);
      const dcRef = useRef(null);
      const [isDrag, setIsDrag] = useState(false);
      const [droppedFiles, setDroppedFiles] = useState([]);
      const [memoSig, setMemoSig] = useState("");
      const [shortCode, setShortCode] = useState("");
      const [waitingForAnswer, setWaitingForAnswer] = useState(false);
      const [connecting, setConnecting] = useState(false);
      
      // Privacy features
      const [showOpSec, setShowOpSec] = useState(false);
      const [scrubbingMetadata, setScrubbingMetadata] = useState(false);
      const [stegoMode, setStegoMode] = useState(false);
      const [stegoImage, setStegoImage] = useState(null);
      const [stegoProcessing, setStegoProcessing] = useState(false);
      const stegoFileRef = useRef(null);
      
      useEffect(()=>{
        if(window.lucide) window.lucide.createIcons();
      });
      
      // Metadata scrubber handler
      async function handleScrubMetadata(){
        const files = fileRef.current?.files || [];
        const dropped = droppedFiles || [];
        const allFiles = [...files, ...dropped];
        
        if (allFiles.length === 0) { pushToast("Attach files first", "err"); return; }
        
        setScrubbingMetadata(true);
        try {
          const scrubbed = [];
          for (const file of allFiles) {
            const clean = await scrubMetadata(file);
            scrubbed.push(clean);
          }
          
          // Create new FileList (can't modify directly)
          const dt = new DataTransfer();
          scrubbed.forEach(f => dt.items.add(f));
          if (fileRef.current) fileRef.current.files = dt.files;
          setDroppedFiles([]);
          
          pushToast(`Metadata removed from ${scrubbed.length} file(s)`, "ok");
        } catch (e) {
          pushToast("Metadata scrubbing failed", "err");
        }
        setScrubbingMetadata(false);
      }
      
      // Steganography mode handler
      async function handleCreateStegoImage(){
        if (!stegoFileRef.current?.files?.[0]) {
          pushToast("Select a cover image first", "err");
          return;
        }
        if (!offerOut) {
          pushToast("Generate an Offer first", "err");
          return;
        }
        
        setStegoProcessing(true);
        try {
          const coverImage = stegoFileRef.current.files[0];
          const hiddenImage = await hideDataInImage(coverImage, offerOut);
          setStegoImage(hiddenImage);
          pushToast("✓ Offer hidden in image! Download and share.", "ok");
        } catch (e) {
          pushToast("Steganography failed: " + e.message, "err");
        }
        setStegoProcessing(false);
      }
      
      async function downloadStegoImage(){
        if (!stegoImage) return;
        const url = URL.createObjectURL(stegoImage);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'vacation-photo.png';
        a.click();
        URL.revokeObjectURL(url);
        pushToast("Image downloaded — share it anywhere!", "ok");
      }

      async function copyOffer(){
        try{ await navigator.clipboard.writeText(offerOut || ""); pushToast("Offer copied", "ok"); }catch(e){ pushToast("Copy failed", "err"); }
      }
      async function shareOffer(){
        try{
          if (!offerOut){ pushToast("Generate an Offer first", "err"); return; }
          const message = `Whistle Courier Offer (Tipster)\n\nPaste this in Newsroom → Step 1 (Paste Offer), click Generate Answer, and send the Answer back.\n\n${offerOut}`;
          if (navigator.share){
            await navigator.share({ title: 'Whistle Courier Offer', text: message });
            pushToast("Shared", "ok");
          } else {
            await navigator.clipboard.writeText(message);
            pushToast("Offer + instructions copied — share anywhere", "ok");
          }
        }catch(e){ pushToast("Share failed", "err"); }
      }
      async function pasteAnswer(){
        try{ const t = await navigator.clipboard.readText(); setAnswerIn(t || ""); if((t||"").trim()) setWaitingForAnswer(false); pushToast("Pasted from clipboard", "ok"); }catch(e){ pushToast("Paste failed", "err"); }
      }
      function resetSender(){
        try{ dcRef.current?.close?.(); }catch{}
        try{ peerRef.current?.close?.(); }catch{}
        setTipText(""); if (fileRef.current) fileRef.current.value="";
        setOfferOut(""); setAnswerIn(""); setConnStatus("Not connected"); setSending(false); setProg(0);
        setWaitingForAnswer(false); setConnecting(false);
        pushToast("Tipster reset", "ok");
      }

      async function makeOffer() {
        try {
          const pc = new RTCPeerConnection({ iceServers: [{ urls: ["stun:stun.l.google.com:19302"] }] });
          peerRef.current = pc;
          const dc = pc.createDataChannel("whistle", { ordered: true });
          dc.binaryType = "arraybuffer";
          dcRef.current = dc;
          dc.onopen = () => { setConnStatus("Connected"); setConnecting(false); };
          dc.onclose = () => { setConnStatus("Closed"); };
          pc.onicecandidate = (e) => { if (!e.candidate) setOfferOut(textToB64(JSON.stringify(pc.localDescription))); };
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          pushToast("Offer created. Copy to newsroom.", "ok");
          setWaitingForAnswer(true);
          setConnecting(false);
        } catch (e) {
          pushToast("Offer failed: " + (e.message || e), "err");
        }
      }

      async function acceptAnswer() {
        try {
          if (!peerRef.current) throw new Error("Create an Offer first");
          const ans = JSON.parse(b64ToText(answerIn.trim()));
          await peerRef.current.setRemoteDescription(new RTCSessionDescription(ans));
          setConnStatus("Connecting…");
          setConnecting(true);
        } catch (e) {
          pushToast("Accept failed: " + (e.message || e), "err");
        }
      }

      async function sendNow() {
        // Show OpSec checklist first
        setShowOpSec(true);
      }
      
      async function actualSend() {
        setShowOpSec(false);
        try {
          const dc = dcRef.current;
          if (!dc || dc.readyState !== "open") throw new Error("Not connected");
          const inputFiles = fileRef.current?.files || [];
          const files = [...inputFiles, ...droppedFiles];
          const { pkgBytes, aesKeyRaw, iv, ct } = await packBundle(tipText, files);
          const hash = await sha256(ct);
          const bundleHash = hex(hash);
          setShortCode(formatShortCode(hash));
          onHashReady(bundleHash);

          setSending(true); setProg(0);
          const header = JSON.stringify({ v: 1, iv: b64(iv), key: b64(aesKeyRaw), ctSize: ct.length });
          dc.send(new TextEncoder().encode(header));
          await new Promise((r) => setTimeout(r, 50));
          const chunk = 64 * 1024; let sent = 0;
          while (sent < ct.length) {
            const part = ct.slice(sent, Math.min(sent + chunk, ct.length));
            dc.send(part);
            sent += part.length;
            setProg(Math.round((sent * 100) / ct.length));
            await new Promise((r) => setTimeout(r, 0));
          }
          setSending(false);
          pushToast("Tip sent", "ok");
          storagePushHistory({ role:'tipster', kind:'sent', hash: bundleHash, short: formatShortCode(hash), at: new Date().toISOString() });

          // Immediately post memo (required)
          try{
            const { Connection, PublicKey, SystemProgram, Transaction, TransactionInstruction } = solanaWeb3;
            await ensureBuffer();
            if (!walletStore.pubkey){
              const r = await window.solana?.connect?.();
              if(!r) throw new Error("Wallet not connected");
              walletStore.pubkey = r.publicKey.toBase58();
              walletStore.setPub(walletStore.pubkey);
            }
            const { http: httpUrl, ws: wsUrl } = getRpcUrls();
            const conn = wsUrl ? new Connection(httpUrl, { commitment:'confirmed', wsEndpoint: wsUrl }) : new Connection(httpUrl, 'confirmed');
            const MEMO = new PublicKey("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr");
            const memoBuf = enc.encode("WHISTLE_HASH:" + bundleHash); // Uint8Array
            const ixMemo = new TransactionInstruction({ keys: [], programId: MEMO, data: memoBuf });
            const ixPing = SystemProgram.transfer({ fromPubkey: new PublicKey(walletStore.pubkey), toPubkey: new PublicKey(walletStore.pubkey), lamports: 0 });
    const tx = new Transaction().add(ixPing, ixMemo);
            tx.feePayer = new PublicKey(walletStore.pubkey);
    tx.recentBlockhash = (await conn.getLatestBlockhash()).blockhash;
    const signed = await window.solana.signTransaction(tx);
            const sig = await conn.sendRawTransaction(signed.serialize(), { skipPreflight: false });
    await conn.confirmTransaction(sig, 'confirmed');
            setMemoSig(sig);
            pushToast("Solana memo posted", "ok");
            storagePushHistory({ role:'tipster', kind:'memo', hash: bundleHash, short: formatShortCode(hash), sig, at: new Date().toISOString() });
          }catch(err){
            const msg = (err && err.message) ? err.message : String(err);
            pushToast("Memo failed: "+msg, "err");
          }
        } catch (e) {
          setSending(false);
          pushToast("Send failed: " + (e.message || e), "err");
        }
      }

      return (
        <>
          <OpSecChecklist open={showOpSec} onClose={()=>setShowOpSec(false)} onConfirm={actualSend} />
          
          <GlassCard title="Sender — Send" subtitle="Compose, connect, and send end-to-end encrypted">
            {/* Privacy Tools */}
            <div className="mb-4 p-3 rounded-xl bg-gradient-to-r from-yellow-500/10 to-orange-500/10 border border-yellow-400/20">
              <div className="flex items-center gap-2 mb-2">
                <i data-lucide="shield-check" className="w-5 h-5 text-yellow-400"></i>
                <h4 className="text-white/90 font-semibold text-sm">Privacy Tools</h4>
              </div>
              <div className="flex flex-wrap gap-2 mb-2">
                <button onClick={(e)=>{ ripple(e); handleScrubMetadata(); }} disabled={scrubbingMetadata} className="flex items-center gap-2 rounded-lg bg-cyan-500/20 hover:bg-cyan-500/30 text-cyan-200 text-xs font-semibold px-3 py-1.5 border border-cyan-400/30 btn-ripple">
                  <i data-lucide={scrubbingMetadata ? "loader" : "eraser"} className={`w-3 h-3 ${scrubbingMetadata ? 'animate-spin' : ''}`}></i>
                  {scrubbingMetadata ? 'Scrubbing...' : 'Scrub Metadata'}
                </button>
                <button onClick={(e)=>{ ripple(e); setStegoMode(!stegoMode); }} className={`flex items-center gap-2 rounded-lg ${stegoMode ? 'bg-purple-500/30 border-purple-400/50' : 'bg-purple-500/20 border-purple-400/30'} hover:bg-purple-500/30 text-purple-200 text-xs font-semibold px-3 py-1.5 border btn-ripple`}>
                  <i data-lucide="image" className="w-3 h-3"></i>
                  {stegoMode ? '✓ Steganography ON' : 'Steganography Mode'}
                </button>
              </div>
              
              {stegoMode && (
                <div className="mt-3 p-3 rounded-xl bg-purple-500/10 border border-purple-400/20 scale-in">
                  <div className="flex items-center gap-2 mb-2">
                    <i data-lucide="eye-off" className="w-4 h-4 text-purple-300"></i>
                    <h5 className="text-white/90 font-semibold text-xs">🎭 Covert Communication Mode</h5>
                  </div>
                  <p className="text-xs text-white/60 mb-2">
                    <strong>The offer will be hidden inside an image.</strong> Share it like a normal photo — no suspicious text codes needed!
                  </p>
                  <input ref={stegoFileRef} type="file" accept="image/*" className="w-full rounded-lg bg-white/[0.06] border border-white/10 p-2 text-xs mb-2" />
                  <div className="flex gap-2">
                    <button onClick={(e)=>{ ripple(e); handleCreateStegoImage(); }} disabled={stegoProcessing || !offerOut} className="flex items-center gap-2 rounded-lg bg-purple-500/30 hover:bg-purple-400/40 disabled:opacity-50 text-purple-100 text-xs font-semibold px-3 py-1.5 border border-purple-400/30 btn-ripple">
                      <i data-lucide={stegoProcessing ? "loader" : "wand-2"} className={`w-3 h-3 ${stegoProcessing ? 'animate-spin' : ''}`}></i>
                      {stegoProcessing ? 'Hiding...' : 'Create Stego Image'}
                    </button>
                    {stegoImage && (
                      <>
                        <button onClick={(e)=>{ ripple(e); downloadStegoImage(); }} className="flex items-center gap-2 rounded-lg bg-emerald-500/30 hover:bg-emerald-400/40 text-emerald-100 text-xs font-semibold px-3 py-1.5 border border-emerald-400/30 btn-ripple">
                          <i data-lucide="download" className="w-3 h-3"></i>
                          Download
                        </button>
                        <button onClick={(e)=>{ ripple(e); 
                          const url = URL.createObjectURL(stegoImage);
                          const preview = window.open('', '_blank');
                          preview.document.write(`<img src="${url}" style="max-width:100%;height:auto;" /><p style="font-family:sans-serif;padding:20px;">👆 Share this image via email, WhatsApp, Twitter, etc. It looks completely normal!</p>`);
                        }} className="flex items-center gap-2 rounded-lg bg-cyan-500/30 hover:bg-cyan-400/40 text-cyan-100 text-xs font-semibold px-3 py-1.5 border border-cyan-400/30 btn-ripple">
                          <i data-lucide="eye" className="w-3 h-3"></i>
                          Preview
                        </button>
                      </>
                    )}
                  </div>
                  {stegoImage && (
                    <div className="mt-3 p-2 rounded-lg bg-emerald-500/20 border border-emerald-400/30 text-xs text-emerald-100">
                      <div className="flex items-center gap-2 mb-1">
                        <i data-lucide="check-circle" className="w-4 h-4"></i>
                        <strong>Ready to share!</strong>
                      </div>
                      <p className="text-white/70">Send via: Email, WhatsApp, Telegram, Twitter DM, Instagram, Facebook, Discord, or any messaging app. The image looks 100% innocent — perfect cover!</p>
                    </div>
                  )}
                  {!offerOut && (
                    <p className="mt-2 text-xs text-yellow-300">⚠ Generate an Offer first (Step A below)</p>
                  )}
                </div>
              )}
              
              <p className="text-xs text-white/50 mt-2">
                <strong>Scrub Metadata:</strong> Removes EXIF/GPS data from images.
                <strong className="ml-2">Steganography:</strong> Hides Offer inside an innocent-looking image.
              </p>
            </div>
            
            <div className="grid md:grid-cols-2 gap-4">
              <div>
                <label className="text-xs text-white/60">Message (text)</label>
                <textarea value={tipText} onChange={(e) => setTipText(e.target.value)} rows={8} className="mt-1 w-full rounded-xl bg-white/[0.06] border border-white/10 p-3 outline-none focus:ring-2 focus:ring-cyan-400/40" placeholder="Describe the issue with verifiable details." />
              </div>
            <div onDragOver={(e)=>{e.preventDefault(); setIsDrag(true);}} onDragLeave={()=>setIsDrag(false)} onDrop={(e)=>{ e.preventDefault(); setIsDrag(false); const files = Array.from(e.dataTransfer.files||[]); setDroppedFiles(files); pushToast(files.length?`Added ${files.length} file(s)`:'No files', files.length?'ok':'err'); }} className={"rounded-xl p-2 "+(isDrag?"border-2 border-dashed border-cyan-400 bg-white/10":"")}>
              <label className="text-xs text-white/60">Attach evidence (≤ 5 GB total)</label>
              <input ref={fileRef} type="file" multiple className="mt-1 w-full rounded-xl bg-white/[0.06] border border-white/10 p-2" />
              <p className="text-xs text-white/50 mt-1">Nothing uploads; it streams directly to the newsroom over an encrypted data channel.</p>
              {droppedFiles.length>0 && (
                <div className="mt-2 text-xs text-white/70">
                  <div className="mb-1">Dropped files:</div>
                  <ul className="list-disc list-inside space-y-0.5">
                    {droppedFiles.map((f,i)=> <li key={i}>{f.name} ({Math.round(f.size/1024)} KB)</li>)}
                  </ul>
                  <button onClick={(e)=>{ ripple(e); setDroppedFiles([]); }} className="mt-2 rounded-xl bg-white/10 hover:bg-white/20 text-white px-3 py-1 border border-white/10 btn-ripple text-xs">Clear dropped</button>
                </div>
              )}
      </div>
    </div>

          <div className="my-4 h-px bg-white/10" />

          {stegoMode && offerOut && (
            <div className="mb-4 p-4 rounded-xl bg-gradient-to-r from-purple-500/20 to-pink-500/20 border-2 border-purple-400/40 scale-in">
              <div className="flex items-center gap-2 mb-2">
                <i data-lucide="shield-check" className="w-5 h-5 text-purple-300"></i>
                <h4 className="text-white/90 font-semibold">🎭 Steganography Mode Active</h4>
              </div>
              <p className="text-sm text-white/80">
                Your Offer is ready. <strong>Don't copy/paste the text below</strong> — instead, use the stego image above. 
                It's hidden inside an innocent-looking photo for maximum security.
              </p>
            </div>
          )}

          <div className="grid md:grid-cols-2 gap-4">
            <div>
              <h4 className="flex items-center gap-2 text-white/90 font-semibold mb-1">
                <i data-lucide="key" className="w-5 h-5 text-cyan-400"></i>
                Step A — Create Offer {stegoMode && '(for Stego Image)'}
              </h4>
              <div className="flex gap-2">
                <button onClick={(e)=>{ ripple(e); makeOffer(); }} className="flex items-center gap-2 rounded-xl bg-cyan-500/80 hover:bg-cyan-400 text-black font-semibold px-4 py-2 btn-ripple active:scale-[.98]">
                  <i data-lucide="plus-circle" className="w-4 h-4"></i>
                  Generate
                </button>
                {!stegoMode && (
                  <>
                    <button onClick={(e)=>{ ripple(e); copyOffer(); }} disabled={!offerOut} className="flex items-center gap-2 rounded-xl bg-white/10 hover:bg-white/20 disabled:opacity-50 text-white font-semibold px-4 py-2 border border-white/10 btn-ripple active:scale-[.98]">
                      <i data-lucide="copy" className="w-4 h-4"></i>
                      Copy
                    </button>
                    <button onClick={(e)=>{ ripple(e); shareOffer(); }} disabled={!offerOut} className="flex items-center gap-2 rounded-xl bg-white/10 hover:bg-white/20 disabled:opacity-50 text-white font-semibold px-4 py-2 border border-white/10 btn-ripple active:scale-[.98]">
                      <i data-lucide="share" className="w-4 h-4"></i>
                      Share
                    </button>
                  </>
                )}
              </div>
              {stegoMode ? (
                <p className="text-xs text-white/50 mt-1">Generated Offer will be hidden in the stego image above. <strong>Don't share this text directly.</strong></p>
              ) : (
                <p className="text-xs text-white/50 mt-1">Copy this text and send it to the receiver. They will respond with an Answer.</p>
              )}
              <textarea readOnly value={offerOut} rows={6} className={`mt-2 w-full rounded-xl ${stegoMode ? 'bg-black/30 opacity-50' : 'bg-black/50'} border border-white/10 p-3 font-mono text-xs`} placeholder={stegoMode ? 'Offer will be hidden in stego image...' : ''} />
              {waitingForAnswer && !answerIn.trim() && connStatus!=="Connected" && (
                <div className="mt-2 flex items-center gap-2 text-xs text-white/60 scale-in">
                  <span className="inline-block h-3 w-3 rounded-full border-2 border-white/30 border-t-cyan-400 animate-spin rotate-slow" />
                  <span className="pulse-glow">Waiting for newsroom Answer…</span>
                </div>
              )}
    </div>
            <div>
              <h4 className="flex items-center gap-2 text-white/90 font-semibold mb-1">
                <i data-lucide="message-square" className="w-5 h-5 text-purple-400"></i>
                Step B — Paste Answer
              </h4>
              <textarea value={answerIn} onChange={(e) => { setAnswerIn(e.target.value); if(e.target.value.trim()) setWaitingForAnswer(false); }} rows={6} className="w-full rounded-xl bg-white/[0.06] border border-white/10 p-3 font-mono text-xs" placeholder="Paste newsroom Answer here" />
              <div className="flex items-center gap-3 mt-2 flex-wrap">
                <button onClick={(e)=>{ ripple(e); pasteAnswer(); }} className="flex items-center gap-2 rounded-xl bg-white/10 hover:bg-white/20 text-white font-semibold px-3 py-2 border border-white/10 btn-ripple active:scale-[.98]">
                  <i data-lucide="clipboard" className="w-4 h-4"></i>
                  Paste
                </button>
                <button onClick={(e)=>{ ripple(e); acceptAnswer(); }} disabled={!answerIn.trim()} className="flex items-center gap-2 rounded-xl bg-white/15 hover:bg-white/25 disabled:opacity-50 text-white font-semibold px-4 py-2 border border-white/10 btn-ripple active:scale-[.98]">
                  <i data-lucide="plug" className="w-4 h-4"></i>
                  Connect
                </button>
                <button onClick={(e)=>{ ripple(e); resetSender(); }} className="flex items-center gap-2 rounded-xl bg-white/5 hover:bg-white/15 text-white font-semibold px-3 py-2 border border-white/10 btn-ripple active:scale-[.98]">
                  <i data-lucide="refresh-cw" className="w-4 h-4"></i>
                  Reset
                </button>
                <span className="flex items-center gap-1 text-xs text-white/60">
                  <i data-lucide="wifi" className="w-3 h-3"></i>
                  {connStatus}
                </span>
              </div>
              {connecting && connStatus!=="Connected" && (
                <div className="mt-2 flex items-center gap-2 text-xs text-white/60 scale-in">
                  <span className="inline-block h-3 w-3 rounded-full border-2 border-white/30 border-t-purple-400 animate-spin rotate-slow" />
                  <span className="pulse-glow">Connecting to newsroom…</span>
    </div>
              )}
    </div>
</div>

          <div className="mt-4">
            <button onClick={(e)=>{ ripple(e); sendNow(); }} className="flex items-center gap-2 justify-center rounded-xl bg-gradient-to-r from-cyan-400 to-purple-400 hover:from-cyan-300 hover:to-purple-300 text-black font-semibold px-6 py-3 disabled:opacity-60 btn-ripple btn-press shadow-lg hover:shadow-xl transition-all" disabled={connStatus !== "Connected" || sending}>
              <i data-lucide={sending ? "loader" : "rocket"} className={`w-5 h-5 ${sending ? 'animate-spin' : ''}`}></i>
              {sending ? "Sending…" : "Send Encrypted Tip"}
            </button>
            {sending && (
              <div className="mt-2 h-2 w-full rounded-full bg-white/10 overflow-hidden scale-in">
                <div className="h-2 progress-shine rounded-full transition-all" style={{ width: `${prog}%` }} />
              </div>
            )}
          </div>
          <div className="text-xs text-white/60 mt-2 space-y-1">
            <p>Short code: <span className="font-mono">{shortCode}</span></p>
            {memoSig && (
              <p>🧾 Memo: <a className="text-cyan-300" target="_blank" rel="noreferrer" href={`https://solscan.io/tx/${memoSig}`}>{memoSig}</a></p>
            )}
          </div>
          </GlassCard>
        </>
      );
    }

    function Receiver({ pushToast, onHashReady, setVerifyHash }) {
      const [offerIn, setOfferIn] = useState("");
      const [answerOut, setAnswerOut] = useState("");
      const [status, setStatus] = useState("Waiting…");
      const [prog, setProg] = useState(0);
      const [text, setText] = useState("");
      const [files, setFiles] = useState([]);
      const [hash, setHash] = useState("");
      const peerRef = useRef(null);
      const dcRef = useRef(null);
      
      // Self-destruct features
      const [selfDestructTime, setSelfDestructTime] = useState(24); // hours
      const [destructCountdown, setDestructCountdown] = useState(null);
      const destructTimerRef = useRef(null);
      
      // Steganography extraction
      const [extractingStegoImage, setExtractingStegoImage] = useState(false);
      const stegoExtractRef = useRef(null);
      
      useEffect(()=>{
        if(window.lucide) window.lucide.createIcons();
      });
      
      // Start self-destruct timer when content is received
      useEffect(() => {
        if (text && selfDestructTime > 0) {
          const destructTime = Date.now() + (selfDestructTime * 60 * 60 * 1000);
          setDestructCountdown(destructTime);
          
          destructTimerRef.current = setInterval(() => {
            const remaining = destructTime - Date.now();
            if (remaining <= 0) {
              setText("");
              setFiles([]);
              setHash("");
              clearInterval(destructTimerRef.current);
              setDestructCountdown(null);
              pushToast("Message self-destructed ✓", "ok");
            }
          }, 1000);
          
          return () => clearInterval(destructTimerRef.current);
        }
      }, [text, selfDestructTime]);

      async function pasteOffer(){
        try{ const t = await navigator.clipboard.readText(); setOfferIn(t || ""); pushToast("Pasted Offer", "ok"); }catch(e){ pushToast("Paste failed", "err"); }
      }
      async function copyAnswer(){
        try{ await navigator.clipboard.writeText(answerOut || ""); pushToast("Answer copied", "ok"); }catch(e){ pushToast("Copy failed", "err"); }
      }
      function resetReceiver(){
        try{ dcRef.current?.close?.(); }catch{}
        try{ peerRef.current?.close?.(); }catch{}
        if (destructTimerRef.current) clearInterval(destructTimerRef.current);
        setOfferIn(""); setAnswerOut(""); setStatus("Waiting…"); setProg(0); setText(""); setFiles([]); setHash(""); setDestructCountdown(null);
        pushToast("Newsroom reset", "ok");
      }
      
      async function extractFromStegoImage(){
        if (!stegoExtractRef.current?.files?.[0]) {
          pushToast("Select an image first", "err");
          return;
        }
        
        setExtractingStegoImage(true);
        try {
          const imageFile = stegoExtractRef.current.files[0];
          const extracted = await extractDataFromImage(imageFile);
          setOfferIn(extracted);
          pushToast("✓ Offer extracted from image!", "ok");
        } catch (e) {
          pushToast("Extraction failed: " + e.message, "err");
        }
        setExtractingStegoImage(false);
      }
      
      function getTimeRemaining(){
        if (!destructCountdown) return '';
        const remaining = destructCountdown - Date.now();
        if (remaining <= 0) return 'Expired';
        const hours = Math.floor(remaining / (1000 * 60 * 60));
        const minutes = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((remaining % (1000 * 60)) / 1000);
        return `${hours}h ${minutes}m ${seconds}s`;
      }

      async function makeAnswer() {
        try {
          const pc = new RTCPeerConnection({ iceServers: [{ urls: ["stun:stun.l.google.com:19302"] }] });
          peerRef.current = pc;
          pc.ondatachannel = (ev) => {
            const dc = ev.channel;
            dcRef.current = dc;
            dc.binaryType = "arraybuffer";
            let rcvAccum = [];
            let rcvExpect = 0;
            let rcvIV = null;
            let rcvKey = null;
            dc.onopen = () => setStatus("Connected");
            dc.onmessage = async (e) => {
              const buf = new Uint8Array(e.data);
              if (!rcvIV) {
                const meta = JSON.parse(new TextDecoder().decode(buf));
                rcvIV = ub64(meta.iv);
                rcvKey = ub64(meta.key);
                rcvExpect = meta.ctSize | 0;
                rcvAccum = [];
                setProg(0);
              } else {
                rcvAccum.push(buf);
                const sofar = rcvAccum.reduce((n, b) => n + b.length, 0);
                setProg(Math.round((sofar * 100) / rcvExpect));
                if (sofar >= rcvExpect) {
                  const ct = new Uint8Array(sofar);
                  let off = 0;
                  for (const b of rcvAccum) { ct.set(b, off); off += b.length; }
                  const pkg = await unpackBundle(rcvKey, rcvIV, ct);
                  setText(pkg.text || "(no text)");
                  setFiles(pkg.files || []);
                  const h = hex(await sha256(ct));
                  setHash(h);
                  setVerifyHash(h);
                  onHashReady(h);
                  setStatus("Received & decrypted");
                  pushToast("Received & decrypted", "ok");
                  storagePushHistory({ role:'newsroom', kind:'received', hash: h, short: formatShortCode(await sha256(ct)), at: new Date().toISOString() });
                }
              }
            };
          };
          pc.onicecandidate = (e) => { if (!e.candidate) setAnswerOut(textToB64(JSON.stringify(pc.localDescription))); };
          const offer = JSON.parse(b64ToText(offerIn.trim()));
          await pc.setRemoteDescription(new RTCSessionDescription(offer));
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          setStatus("Answer created. Send it back to tipster.");
          pushToast("Answer ready", "ok");
        } catch (e) {
          pushToast("Answer failed: " + (e.message || e), "err");
        }
      }

      return (
        <GlassCard title="Receiver — Receive" subtitle="Paste Offer, generate Answer, accept the stream">
          {/* Steganography Extraction */}
          <div className="mb-4 p-3 rounded-xl bg-gradient-to-r from-purple-500/10 to-pink-500/10 border border-purple-400/20">
            <div className="flex items-center gap-2 mb-2">
              <i data-lucide="image-plus" className="w-5 h-5 text-purple-400"></i>
              <h4 className="text-white/90 font-semibold text-sm">Extract Offer from Image</h4>
            </div>
            <p className="text-xs text-white/60 mb-2">If sender used steganography, upload the image to extract the hidden Offer.</p>
            <div className="flex gap-2 items-end">
              <div className="flex-1">
                <input ref={stegoExtractRef} type="file" accept="image/*" className="w-full rounded-lg bg-white/[0.06] border border-white/10 p-2 text-xs" />
              </div>
              <button onClick={(e)=>{ ripple(e); extractFromStegoImage(); }} disabled={extractingStegoImage} className="flex items-center gap-2 rounded-lg bg-purple-500/30 hover:bg-purple-400/40 text-purple-100 text-xs font-semibold px-3 py-2 border border-purple-400/30 btn-ripple">
                <i data-lucide={extractingStegoImage ? "loader" : "scan"} className={`w-3 h-3 ${extractingStegoImage ? 'animate-spin' : ''}`}></i>
                {extractingStegoImage ? 'Extracting...' : 'Extract Offer'}
              </button>
            </div>
          </div>
          
          {/* Self-Destruct Settings */}
          <div className="mb-4 p-3 rounded-xl bg-gradient-to-r from-orange-500/10 to-red-500/10 border border-orange-400/20">
            <div className="flex items-center gap-2 mb-2">
              <i data-lucide="timer" className="w-5 h-5 text-orange-400"></i>
              <h4 className="text-white/90 font-semibold text-sm">Self-Destruct Timer</h4>
            </div>
            <p className="text-xs text-white/60 mb-2">Messages will automatically delete after this time. No trace left.</p>
            <div className="flex items-center gap-3">
              <select value={selfDestructTime} onChange={(e)=>setSelfDestructTime(Number(e.target.value))} className="rounded-lg bg-white/[0.06] border border-white/10 p-2 text-xs text-white">
                <option value="0">Disabled</option>
                <option value="1">1 hour</option>
                <option value="6">6 hours</option>
                <option value="12">12 hours</option>
                <option value="24">24 hours (default)</option>
                <option value="72">3 days</option>
              </select>
              {destructCountdown && (
                <span className="text-xs text-orange-300 font-mono flex items-center gap-1">
                  <i data-lucide="clock" className="w-3 h-3"></i>
                  Deletes in: {getTimeRemaining()}
                </span>
              )}
            </div>
          </div>
          
          <div className="grid md:grid-cols-2 gap-4">
            <div>
              <h4 className="flex items-center gap-2 text-white/90 font-semibold mb-1">
                <i data-lucide="inbox" className="w-5 h-5 text-cyan-400"></i>
                Step 1 — Paste Offer
              </h4>
               <p className="text-xs text-white/50 mb-1">Paste the code the sender sent you. Then click <span className="text-white/70 font-semibold">Generate Answer</span> and send the Answer back to the sender.</p>
              <textarea value={offerIn} onChange={(e) => setOfferIn(e.target.value)} rows={6} className="w-full rounded-xl bg-white/[0.06] border border-white/10 p-3 font-mono text-xs" placeholder="Paste tipster Offer here (or extract from image above)" />
              <div className="flex gap-2 mt-2 flex-wrap">
                <button onClick={(e)=>{ ripple(e); pasteOffer(); }} className="flex items-center gap-2 rounded-xl bg-white/10 hover:bg-white/20 text-white font-semibold px-3 py-2 border border-white/10 btn-ripple active:scale-[.98]">
                  <i data-lucide="clipboard" className="w-4 h-4"></i>
                  Paste Offer
                </button>
                <button onClick={(e)=>{ ripple(e); makeAnswer(); }} className="flex items-center gap-2 rounded-xl bg-cyan-500/80 hover:bg-cyan-400 text-black font-semibold px-4 py-2 btn-ripple active:scale-[.98]">
                  <i data-lucide="plus-circle" className="w-4 h-4"></i>
                  Generate Answer
                </button>
              </div>
              <div className="flex gap-2 mt-2">
                <button onClick={(e)=>{ ripple(e); copyAnswer(); }} disabled={!answerOut} className="flex items-center gap-2 rounded-xl bg-white/10 hover:bg-white/20 disabled:opacity-50 text-white font-semibold px-3 py-2 border border-white/10 btn-ripple active:scale-[.98]">
                  <i data-lucide="copy" className="w-4 h-4"></i>
                  Copy Answer
                </button>
                <button onClick={(e)=>{ ripple(e); resetReceiver(); }} className="flex items-center gap-2 rounded-xl bg-white/5 hover:bg-white/15 text-white font-semibold px-3 py-2 border border-white/10 btn-ripple active:scale-[.98]">
                  <i data-lucide="refresh-cw" className="w-4 h-4"></i>
                  Reset
                </button>
              </div>
              <textarea readOnly value={answerOut} rows={6} className="mt-2 w-full rounded-xl bg-black/50 border border-white/10 p-3 font-mono text-xs" placeholder="Copy this Answer back to tipster" />
            </div>
            <div>
              <h4 className="flex items-center gap-2 text-white/90 font-semibold mb-1">
                <i data-lucide="activity" className="w-5 h-5 text-emerald-400"></i>
                Status
              </h4>
              <p className="flex items-center gap-2 text-xs text-white/60 pulse-glow">
                <i data-lucide="info" className="w-3 h-3"></i>
                {status}
              </p>
              <div className="mt-2 h-2 w-full rounded-full bg-white/10 overflow-hidden">
                <div className="h-2 progress-shine rounded-full transition-all" style={{ width: `${prog}%` }} />
              </div>
            </div>
          </div>

          <div className="my-4 h-px bg-white/10" />

           <div className="scale-in">
             <h4 className="flex items-center gap-2 text-white/90 font-semibold mb-1">
               <i data-lucide="file-text" className="w-5 h-5 text-emerald-400"></i>
               Decrypted Tip
             </h4>
             <pre className="font-mono text-xs bg-black/40 p-3 rounded-xl border border-white/10 min-h-[96px] whitespace-pre-wrap hover:border-cyan-400/20 transition-all">{text}</pre>
             <div className="mt-2 space-y-1">
               {files.map((x, i) => (
                 <a key={i} href={URL.createObjectURL(new Blob([ub64(x.b64)], { type: x.type || "application/octet-stream" }))} download={x.name} className="flex items-center gap-2 text-cyan-300 hover:text-cyan-200 text-sm hover:translate-x-1 transition-transform">
                   <i data-lucide="paperclip" className="w-4 h-4"></i>
                   Download {x.name} ({x.type || "file"})
                 </a>
               ))}
             </div>
             <p className="flex items-center gap-2 text-xs text-white/60 mt-2">
               <i data-lucide="hash" className="w-4 h-4"></i>
               Bundle hash: <span className="font-mono shimmer-bg">{hash}</span>
             </p>
           </div>
        </GlassCard>
      );
    }

    function VerifyMemo({ pushToast, verifyHash }) {
      const [hashIn, setHashIn] = useState(verifyHash || "");
      const [memoSig, setMemoSig] = useState("");
      const [hist, setHist] = useState(storageGetHistory());
      
      useEffect(()=>{
        if(window.lucide) window.lucide.createIcons();
      });
      useEffect(()=>{
        function onH(){ setHist(storageGetHistory()); }
        window.addEventListener('whHistory', onH);
        return ()=> window.removeEventListener('whHistory', onH);
      },[]);

      useEffect(() => { if (verifyHash) setHashIn(verifyHash); }, [verifyHash]);

      async function postMemo() {
        try {
          let hash;
          try{ hash = parseHashOrCode(hashIn); }
          catch{ throw new Error("Enter 64-hex or whis.xxxx short code"); }
          if (!walletStore.pubkey) {
            const r = await window.solana?.connect?.();
            if (!r) throw new Error("Wallet not connected");
            walletStore.pubkey = r.publicKey.toBase58();
            walletStore.setPub(walletStore.pubkey);
          }
          const { Connection, PublicKey, SystemProgram, Transaction, TransactionInstruction } = solanaWeb3;
          await ensureBuffer();
          const { http: httpUrl, ws: wsUrl } = getRpcUrls();
          const conn = wsUrl
            ? new Connection(httpUrl, { commitment: 'confirmed', wsEndpoint: wsUrl })
            : new Connection(httpUrl, 'confirmed');
          const MEMO = new PublicKey("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr");
          const memoBuf = enc.encode("WHISTLE_HASH:" + hash); // Uint8Array
          const ixMemo = new TransactionInstruction({ keys: [], programId: MEMO, data: memoBuf });
          const ixPing = SystemProgram.transfer({ fromPubkey: new PublicKey(walletStore.pubkey), toPubkey: new PublicKey(walletStore.pubkey), lamports: 0 });
    const tx = new Transaction().add(ixPing, ixMemo);
          tx.feePayer = new PublicKey(walletStore.pubkey);
    tx.recentBlockhash = (await conn.getLatestBlockhash()).blockhash;
    const signed = await window.solana.signTransaction(tx);
          const sig = await conn.sendRawTransaction(signed.serialize(), { skipPreflight: false });
          await conn.confirmTransaction(sig, "confirmed");
          setMemoSig(sig);
          pushToast("Memo posted", "ok");
        } catch (e) {
          const msg = (e && e.message) ? e.message : String(e);
          if (msg.includes('403')){
            pushToast("Memo failed: RPC access forbidden (403). Check custom RPC HTTP/WS.", "err");
          } else {
            pushToast("Memo failed: " + msg, "err");
          }
        }
      }

      return (
        <GlassCard title="Verify / Memo" subtitle="Post Solana Memo with the bundle hash (required)">
          <div className="grid md:grid-cols-2 gap-4">
            <div>
              <label className="text-xs text-white/60">Bundle hash (sha256 hex or short code)</label>
              <input value={hashIn} onChange={(e) => setHashIn(e.target.value)} placeholder="e.g., 4f2c… or whis.abcd.efgh…" className="mt-1 w-full rounded-xl bg-white/[0.06] border border-white/10 p-3 font-mono text-xs outline-none focus:ring-2 focus:ring-cyan-400/40" />

              <button onClick={postMemo} className="mt-3 rounded-xl bg-white/15 hover:bg-white/25 text-white font-semibold px-4 py-2 border border-white/10">Post Memo</button>
              {memoSig && (
                <p className="text-xs text-white/60 mt-2">🧾 Memo: <a className="text-cyan-300" target="_blank" rel="noreferrer" href={`https://solscan.io/tx/${memoSig}`}>{memoSig}</a></p>
              )}
            </div>
            <div className="text-xs text-white/70 space-y-2">
              <div className="flex items-center justify-between">
                <h4 className="text-white/90 font-semibold">History</h4>
                <button onClick={()=>{ setHistory([]); setHistory([]); setHistory([]); setHistory([]); setHistory([]); /* noop */ }} className="hidden" />
                <button onClick={()=>{ setHistory([]); setHistory([]); }} className="hidden" />
                <button onClick={()=>{ setHistory([]); }} className="hidden" />
              </div>
              <div className="rounded-xl bg-white/[0.04] border border-white/10 max-h-64 overflow-auto">
                {hist.length === 0 && <div className="p-3 text-white/50">No previous items.</div>}
                {hist.map((h)=> (
                  <div key={h.id} className="flex items-center justify-between px-3 py-2 border-b border-white/5">
                    <div className="min-w-0">
                      <div className="text-white/80 font-mono truncate">{h.short}</div>
                      <div className="text-white/40 text-[11px]">{h.kind} • {new Date(h.at).toLocaleString()}</div>
                    </div>
                    <div className="flex gap-2 ml-3 shrink-0">
                      <button onClick={async ()=>{ try{ await navigator.clipboard.writeText(h.short); pushToast('Copied short code','ok'); }catch{} }} className="rounded-md bg-white/10 hover:bg-white/20 text-white text-[11px] px-2 py-1 border border-white/10">Copy</button>
                      <button onClick={async ()=>{ try{ await navigator.clipboard.writeText(h.hash); pushToast('Copied hash','ok'); }catch{} }} className="rounded-md bg-white/10 hover:bg-white/20 text-white text-[11px] px-2 py-1 border border-white/10">Hash</button>
                    </div>
                  </div>
                ))}
              </div>
              <div className="flex gap-2">
                <button onClick={()=> setHist(storageGetHistory())} className="rounded-md bg-white/10 hover:bg-white/20 text-white text-[11px] px-2 py-1 border border-white/10">Refresh</button>
                <button onClick={()=>{ setHistory([]); setHistory([]); setHistory([]); setHistory([]); setHistory([]); }} className="hidden" />
                <button onClick={()=>{ setHistory([]); setHistory([]); }} className="hidden" />
                <button onClick={()=>{ setHistory([]); setHistory([]); }} className="hidden" />
                <button onClick={()=>{ setHistory([]); setHistory([]); }} className="hidden" />
                <button onClick={()=>{ setHistory([]); setHistory([]); }} className="hidden" />
                <button onClick={()=>{ setHistory([]); setHistory([]); }} className="hidden" />
                <button onClick={()=>{ storageSetHistory([]); setHist([]); }} className="rounded-md bg-rose-500/20 hover:bg-rose-500/30 text-rose-100 text-[11px] px-2 py-1 border border-rose-400/30">Clear (local)</button>
              </div>
            </div>
          </div>
        </GlassCard>
      );
    }

    // ===== STEGANOGRAPHY-ONLY COMMUNICATION SECTION =====
    
    function StegoSender({ pushToast }) {
      const [message, setMessage] = useState("");
      const [stegoImage, setStegoImage] = useState(null);
      const [processing, setProcessing] = useState(false);
      const coverImageRef = useRef(null);
      
      useEffect(()=>{
        if(window.lucide) window.lucide.createIcons();
      });
      
      async function createStegoImage() {
        if (!message.trim()) {
          pushToast("Write a message first", "err");
          return;
        }
        if (!coverImageRef.current?.files?.[0]) {
          pushToast("Select a cover image", "err");
          return;
        }
        
        setProcessing(true);
        try {
          const coverImage = coverImageRef.current.files[0];
          const hiddenImage = await hideDataInImage(coverImage, message);
          setStegoImage(hiddenImage);
          pushToast("✓ Message hidden in image!", "ok");
        } catch (e) {
          pushToast("Failed: " + e.message, "err");
        }
        setProcessing(false);
      }
      
      function downloadImage() {
        if (!stegoImage) return;
        const url = URL.createObjectURL(stegoImage);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'photo.png';
        a.click();
        URL.revokeObjectURL(url);
        pushToast("Image downloaded!", "ok");
      }
      
      function resetStegoSender() {
        setMessage("");
        setStegoImage(null);
        if (coverImageRef.current) coverImageRef.current.value = "";
        pushToast("Reset", "ok");
      }
      
      return (
        <GlassCard title="🎭 Steganography — Sender" subtitle="Hide your message inside an innocent-looking image">
          <div className="space-y-4">
            <div>
              <label className="text-sm text-white/80 font-semibold mb-2 block">Your Secret Message</label>
              <textarea 
                value={message} 
                onChange={(e) => setMessage(e.target.value)} 
                rows={6} 
                className="w-full rounded-xl bg-white/[0.06] border border-white/10 p-3 outline-none focus:ring-2 focus:ring-purple-400/40 text-white" 
                placeholder="Type your confidential message here..."
              />
              <p className="text-xs text-white/50 mt-1">This message will be invisible to anyone looking at the image.</p>
            </div>
            
            <div>
              <label className="text-sm text-white/80 font-semibold mb-2 block">Cover Image</label>
              <input 
                ref={coverImageRef} 
                type="file" 
                accept="image/*" 
                className="w-full rounded-xl bg-white/[0.06] border border-white/10 p-3 text-sm file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-purple-500/30 file:text-purple-100 hover:file:bg-purple-500/40"
              />
              <p className="text-xs text-white/50 mt-1">Choose any image: vacation photo, pet, landscape, meme, etc.</p>
            </div>
            
            <div className="flex gap-3 flex-wrap">
              <button 
                onClick={(e)=>{ ripple(e); createStegoImage(); }} 
                disabled={processing}
                className="flex items-center gap-2 rounded-xl bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-400 hover:to-pink-400 disabled:opacity-50 text-white font-semibold px-6 py-3 btn-ripple btn-press shadow-lg"
              >
                <i data-lucide={processing ? "loader" : "wand-2"} className={`w-5 h-5 ${processing ? 'animate-spin' : ''}`}></i>
                {processing ? "Hiding Message..." : "Create Stego Image"}
              </button>
              
              {stegoImage && (
                <>
                  <button 
                    onClick={(e)=>{ ripple(e); downloadImage(); }}
                    className="flex items-center gap-2 rounded-xl bg-emerald-500/80 hover:bg-emerald-400 text-white font-semibold px-6 py-3 btn-ripple btn-press"
                  >
                    <i data-lucide="download" className="w-5 h-5"></i>
                    Download Image
                  </button>
                  
                  <button 
                    onClick={(e)=>{ ripple(e); 
                      const url = URL.createObjectURL(stegoImage);
                      const preview = window.open('', '_blank');
                      preview.document.write(`
                        <html><head><title>Stego Image Preview</title></head>
                        <body style="margin:0;padding:20px;background:#111;color:#fff;font-family:sans-serif;">
                          <h2>✅ Your Steganography Image</h2>
                          <img src="${url}" style="max-width:100%;height:auto;border-radius:12px;box-shadow:0 10px 40px rgba(0,0,0,0.5);" />
                          <p>👆 This image looks completely normal, but contains your hidden message!</p>
                          <p>Share it via email, WhatsApp, Twitter, Instagram, or any messaging platform.</p>
                        </body></html>
                      `);
                    }}
                    className="flex items-center gap-2 rounded-xl bg-cyan-500/80 hover:bg-cyan-400 text-white font-semibold px-6 py-3 btn-ripple btn-press"
                  >
                    <i data-lucide="eye" className="w-5 h-5"></i>
                    Preview
                  </button>
                </>
              )}
              
              <button 
                onClick={(e)=>{ ripple(e); resetStegoSender(); }}
                className="flex items-center gap-2 rounded-xl bg-white/10 hover:bg-white/20 text-white font-semibold px-4 py-3 border border-white/10 btn-ripple btn-press"
              >
                <i data-lucide="refresh-cw" className="w-4 h-4"></i>
                Reset
              </button>
            </div>
            
            {stegoImage && (
              <div className="mt-4 p-4 rounded-xl bg-gradient-to-r from-emerald-500/20 to-cyan-500/20 border border-emerald-400/30 scale-in">
                <div className="flex items-center gap-2 mb-2">
                  <i data-lucide="check-circle" className="w-5 h-5 text-emerald-300"></i>
                  <h4 className="text-white/90 font-semibold">✅ Stego Image Ready!</h4>
                </div>
                <p className="text-sm text-white/80 mb-2">
                  Your message is now hidden inside the image. Share it anywhere:
                </p>
                <div className="flex flex-wrap gap-2 text-xs">
                  <span className="px-3 py-1 rounded-lg bg-white/10 border border-white/20">📧 Email</span>
                  <span className="px-3 py-1 rounded-lg bg-white/10 border border-white/20">💬 WhatsApp</span>
                  <span className="px-3 py-1 rounded-lg bg-white/10 border border-white/20">🐦 Twitter</span>
                  <span className="px-3 py-1 rounded-lg bg-white/10 border border-white/20">📸 Instagram</span>
                  <span className="px-3 py-1 rounded-lg bg-white/10 border border-white/20">💼 LinkedIn</span>
                  <span className="px-3 py-1 rounded-lg bg-white/10 border border-white/20">📱 Telegram</span>
                </div>
                <p className="text-xs text-white/60 mt-2">
                  🔒 Perfect plausible deniability — it's just a normal photo!
                </p>
              </div>
            )}
          </div>
        </GlassCard>
      );
    }
    
    function StegoReceiver({ pushToast }) {
      const [extractedMessage, setExtractedMessage] = useState("");
      const [extracting, setExtracting] = useState(false);
      const imageFileRef = useRef(null);
      
      useEffect(()=>{
        if(window.lucide) window.lucide.createIcons();
      });
      
      async function extractMessage() {
        if (!imageFileRef.current?.files?.[0]) {
          pushToast("Select an image first", "err");
          return;
        }
        
        setExtracting(true);
        try {
          const imageFile = imageFileRef.current.files[0];
          const extracted = await extractDataFromImage(imageFile);
          setExtractedMessage(extracted);
          pushToast("✓ Message extracted!", "ok");
        } catch (e) {
          pushToast("Extraction failed: " + e.message, "err");
          setExtractedMessage("");
        }
        setExtracting(false);
      }
      
      async function copyMessage() {
        try {
          await navigator.clipboard.writeText(extractedMessage);
          pushToast("Message copied", "ok");
        } catch (e) {
          pushToast("Copy failed", "err");
        }
      }
      
      function resetStegoReceiver() {
        setExtractedMessage("");
        if (imageFileRef.current) imageFileRef.current.value = "";
        pushToast("Reset", "ok");
      }
      
      return (
        <GlassCard title="🎭 Steganography — Receiver" subtitle="Extract hidden messages from images">
          <div className="space-y-4">
            <div>
              <label className="text-sm text-white/80 font-semibold mb-2 block">Upload Image with Hidden Message</label>
              <input 
                ref={imageFileRef} 
                type="file" 
                accept="image/*" 
                onChange={() => setExtractedMessage("")}
                className="w-full rounded-xl bg-white/[0.06] border border-white/10 p-3 text-sm file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-purple-500/30 file:text-purple-100 hover:file:bg-purple-500/40"
              />
              <p className="text-xs text-white/50 mt-1">Select the image you received from the sender.</p>
            </div>
            
            <div className="flex gap-3">
              <button 
                onClick={(e)=>{ ripple(e); extractMessage(); }} 
                disabled={extracting}
                className="flex items-center gap-2 rounded-xl bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-400 hover:to-pink-400 disabled:opacity-50 text-white font-semibold px-6 py-3 btn-ripple btn-press shadow-lg"
              >
                <i data-lucide={extracting ? "loader" : "scan"} className={`w-5 h-5 ${extracting ? 'animate-spin' : ''}`}></i>
                {extracting ? "Extracting..." : "Extract Message"}
              </button>
              
              {extractedMessage && (
                <button 
                  onClick={(e)=>{ ripple(e); copyMessage(); }}
                  className="flex items-center gap-2 rounded-xl bg-cyan-500/80 hover:bg-cyan-400 text-white font-semibold px-6 py-3 btn-ripple btn-press"
                >
                  <i data-lucide="copy" className="w-5 h-5"></i>
                  Copy Message
                </button>
              )}
              
              <button 
                onClick={(e)=>{ ripple(e); resetStegoReceiver(); }}
                className="flex items-center gap-2 rounded-xl bg-white/10 hover:bg-white/20 text-white font-semibold px-4 py-3 border border-white/10 btn-ripple btn-press"
              >
                <i data-lucide="refresh-cw" className="w-4 h-4"></i>
                Reset
              </button>
            </div>
            
            {extractedMessage && (
              <div className="mt-4 scale-in">
                <label className="text-sm text-white/80 font-semibold mb-2 block flex items-center gap-2">
                  <i data-lucide="lock-open" className="w-4 h-4 text-emerald-400"></i>
                  Extracted Message
                </label>
                <div className="rounded-xl bg-emerald-500/10 border border-emerald-400/30 p-4">
                  <pre className="whitespace-pre-wrap text-sm text-white/90 font-mono">{extractedMessage}</pre>
                </div>
                <p className="text-xs text-white/60 mt-2">
                  ✅ Message successfully extracted from the image!
                </p>
              </div>
            )}
            
            {!extractedMessage && !extracting && (
              <div className="p-4 rounded-xl bg-purple-500/10 border border-purple-400/20">
                <div className="flex items-center gap-2 mb-2">
                  <i data-lucide="info" className="w-4 h-4 text-purple-300"></i>
                  <h4 className="text-white/90 font-semibold text-sm">How it works</h4>
                </div>
                <ul className="text-xs text-white/70 space-y-1 list-disc list-inside">
                  <li>Sender hides a message inside a normal-looking image</li>
                  <li>The image looks 100% innocent to anyone else</li>
                  <li>You upload that image here to reveal the hidden message</li>
                  <li>Perfect for covert communication!</li>
                </ul>
              </div>
            )}
          </div>
        </GlassCard>
      );
    }

    function App() {
      const { toasts, push } = useToasts();
      const [step, setStep] = usePersistentState('uiStep', "home");
      const [hashFromFlow, setHashFromFlow] = useState("");
      return (
        <div className="relative min-h-screen text-white">
          {/* animated gradient blobs */}
          <div className="sky"></div>
          <div className="sky-dim"></div>
          <div className="pointer-events-none absolute inset-0 -z-10 overflow-hidden">
            <div className="cloud c1"></div>
            <div className="cloud c2"></div>
            <div className="cloud c3"></div>
            <div className="cloud c4"></div>
            <div className="cloud c5"></div>
            <div className="cloud c6"></div>
            <div className="cloud c7"></div>
            <div className="cloud c8"></div>
            <div className="cloud c9"></div>
          </div>
          <div className="max-w-6xl mx-auto p-6">
            <SectionHeader />
            <div className="mt-5 flex gap-6">
              <Sidebar step={step} setStep={setStep} />
              <main className="flex-1 min-w-0">
                <div className="mb-4 md:hidden">
                  <StepPills step={step} setStep={setStep} />
                </div>
                {step === 'home' && <Home setStep={setStep} />}
                {step === 'send' && <Sender pushToast={push} onHashReady={setHashFromFlow} />}
                {step === 'receive' && <Receiver pushToast={push} onHashReady={setHashFromFlow} setVerifyHash={setHashFromFlow} />}
                {step === 'stego-send' && <StegoSender pushToast={push} />}
                {step === 'stego-receive' && <StegoReceiver pushToast={push} />}
              </main>
            </div>
          </div>

          {/* Toasts */}
          <div className="fixed right-4 bottom-4 space-y-2">
            {toasts.map((t) => (
              <div key={t.id} className={`toast-enter rounded-xl border px-4 py-2 text-sm backdrop-blur-xl ${
                t.tone === "ok"
                  ? "bg-emerald-400/15 border-emerald-400/30 text-emerald-200"
                  : t.tone === "err"
                  ? "bg-rose-400/15 border-rose-400/30 text-rose-200"
                  : "bg-white/10 border-white/15 text-white/80"
              }`}>{t.msg}</div>
            ))}
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>
</body>
</html>


