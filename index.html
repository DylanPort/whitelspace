<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
  <title>Whistle — P2P encrypted tips + Solana memo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Ensure Buffer exists before Solana Web3 (fixes Buffer issues in browser) -->
  <script>window.global = window.global || window;</script>
  <script type="module">import { Buffer } from 'https://esm.sh/buffer@6.0.3'; window.Buffer = Buffer;</script>
  <script crossorigin src="https://unpkg.com/@solana/web3.js@1.95.3/lib/index.iife.min.js"></script>
<style>
    html,body{height:100%}
    body{background:#0b0f14}
    /* Premium dynamic visuals */
    @keyframes gradientMove{0%{transform:translate3d(-6%, -4%, 0) scale(1)}100%{transform:translate3d(6%, 4%, 0) scale(1.08)}}
    @keyframes floatSlow{0%{transform:translateY(0)}50%{transform:translateY(-4px)}100%{transform:translateY(0)}}
    @keyframes ripple{0%{transform:scale(0);opacity:.5}100%{transform:scale(4);opacity:0}}
    @keyframes toastIn{0%{transform:translateY(8px);opacity:0}100%{transform:translateY(0);opacity:1}}
    .bg-anim{animation:gradientMove 14s ease-in-out infinite alternate}
    .float-slow{animation:floatSlow 6s ease-in-out infinite}
    .glass-hover{transition:transform .3s ease, box-shadow .3s ease}
    .glass-hover:hover{transform:translateY(-2px);box-shadow:0 20px 40px rgba(0,0,0,.35)}
    .btn-ripple{position:relative;overflow:hidden}
    .btn-ripple span.ripple{position:absolute;border-radius:9999px;background:rgba(255,255,255,.35);transform:scale(0);animation:ripple .6s linear;pointer-events:none}
    .toast-enter{animation:toastIn .4s cubic-bezier(0.68, -0.55, 0.265, 1.55)}
    @keyframes toastIn{
      0%{transform:translateX(400px) scale(0.8);opacity:0}
      100%{transform:translateX(0) scale(1);opacity:1}
    }

     /* Animated sky with clouds */
     .sky{position:fixed;inset:0;pointer-events:none;z-index:-9;background:linear-gradient(180deg,#7ec8ff 0%, #bfe4ff 45%, #e8f4ff 100%)}
     .cloud{position:absolute;filter:blur(0px);opacity:.95}
    .cloud::before{content:"";position:absolute;inset:0; background:
      radial-gradient(120px 70px at 60px 60px, rgba(255,255,255,.95) 40%, rgba(255,255,255,0) 60%),
      radial-gradient(100px 60px at 120px 60px, rgba(255,255,255,.95) 40%, rgba(255,255,255,0) 60%),
      radial-gradient(140px 80px at 180px 70px, rgba(255,255,255,.95) 40%, rgba(255,255,255,0) 60%),
      radial-gradient(110px 65px at 110px 90px, rgba(255,255,255,.95) 40%, rgba(255,255,255,0) 60%);
    }
    @keyframes cloudDrift{from{transform:translateX(-35%)}to{transform:translateX(135%)}}
    .c1{top:12%;left:-30%;width:420px;height:160px;animation:cloudDrift 55s linear infinite}
    .c2{top:28%;left:-40%;width:520px;height:190px;animation:cloudDrift 85s linear infinite}
    .c3{top:42%;left:-35%;width:360px;height:140px;animation:cloudDrift 60s linear infinite}
    .c4{top:58%;left:-45%;width:620px;height:200px;animation:cloudDrift 95s linear infinite}
    .c5{top:70%;left:-38%;width:380px;height:140px;animation:cloudDrift 70s linear infinite}
    .c6{top:18%;left:-48%;width:300px;height:120px;animation:cloudDrift 72s linear infinite}
    .c7{top:35%;left:-52%;width:260px;height:110px;animation:cloudDrift 66s linear infinite}
    .c8{top:64%;left:-50%;width:440px;height:170px;animation:cloudDrift 88s linear infinite}
    .c9{top:78%;left:-46%;width:300px;height:120px;animation:cloudDrift 76s linear infinite}

    /* Dim overlay to ensure text contrast */
    .sky-dim{position:fixed;inset:0;pointer-events:none;z-index:-8;background:linear-gradient(180deg,rgba(0,0,0,.38) 0%, rgba(0,0,0,.32) 35%, rgba(0,0,0,.28) 65%, rgba(0,0,0,.36) 100%)}

    /* Stronger glass panels for readability */
    .glass-strong{background:rgba(10,14,20,.58)!important;border-color:rgba(255,255,255,.12)!important;box-shadow:0 24px 60px rgba(0,0,0,.45)!important}
    .panel-strong{background:rgba(10,14,20,.58)!important;border-color:rgba(255,255,255,.12)!important}

    /* Home: premium animations */
    @keyframes fadeUp{0%{opacity:0;transform:translateY(12px)}100%{opacity:1;transform:translateY(0)}}
    @keyframes slideInLeft{0%{opacity:0;transform:translateX(-20px)}100%{opacity:1;transform:translateX(0)}}
    @keyframes slideInRight{0%{opacity:0;transform:translateX(20px)}100%{opacity:1;transform:translateX(0)}}
    @keyframes scaleIn{0%{opacity:0;transform:scale(.94)}100%{opacity:1;transform:scale(1)}}
    @keyframes shimmer{0%{background-position:200% center}100%{background-position:-200% center}}
    @keyframes pulse{0%,100%{opacity:1}50%{opacity:.6}}
    @keyframes bounce{0%,100%{transform:translateY(0)}50%{transform:translateY(-6px)}}
    @keyframes rotate{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}
    @keyframes glow{0%,100%{box-shadow:0 0 20px rgba(103,232,249,.3)}50%{box-shadow:0 0 40px rgba(103,232,249,.6),0 0 60px rgba(167,139,250,.4)}}
    
    .fade-up{animation:fadeUp .5s ease-out both}
    .fade-up-2{animation:fadeUp .6s ease-out .05s both}
    .fade-up-3{animation:fadeUp .6s ease-out .1s both}
    .slide-in-left{animation:slideInLeft .5s ease-out both}
    .slide-in-right{animation:slideInRight .5s ease-out both}
    .scale-in{animation:scaleIn .4s cubic-bezier(.34,1.56,.64,1) both}
    
    .hover-lift{transition:transform .25s ease, box-shadow .25s ease}
    .hover-lift:hover{transform:translateY(-3px) scale(1.01);box-shadow:0 18px 40px rgba(0,0,0,.45)}
    
    .badge-step{display:inline-flex;align-items:center;justify-content:center;width:22px;height:22px;border-radius:9999px;background:linear-gradient(135deg,#67e8f9,#a78bfa);color:#0b0f14;font-weight:700;font-size:12px;margin-right:8px;animation:glow 3s ease-in-out infinite}
    
    .step-card{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.10);border-radius:16px;padding:10px;transition:all .3s ease}
    .step-card:hover{background:rgba(255,255,255,.06);border-color:rgba(103,232,249,.2)}
    
    .mini-code{background:rgba(0,0,0,.45);border:1px solid rgba(255,255,255,.12);border-radius:8px;padding:8px;transition:all .3s ease}
    .mini-code:hover{border-color:rgba(103,232,249,.3);box-shadow:0 0 20px rgba(103,232,249,.15)}
    
    .shimmer-bg{background:linear-gradient(90deg,rgba(255,255,255,0) 0%,rgba(255,255,255,.08) 50%,rgba(255,255,255,0) 100%);background-size:200% 100%;animation:shimmer 3s linear infinite}
    
    .pulse-glow{animation:pulse 2s ease-in-out infinite}
    
    .bounce-slow{animation:bounce 3s ease-in-out infinite}
    
    .rotate-slow{animation:rotate 20s linear infinite}
    
    /* Progress bar animations */
    @keyframes progressShine{0%{background-position:-100% 0}100%{background-position:200% 0}}
    .progress-shine{background:linear-gradient(90deg,#67e8f9 0%,#a78bfa 50%,#67e8f9 100%);background-size:200% 100%;animation:progressShine 2s linear infinite}
    
    /* Button press effect */
    .btn-press{transition:all .15s ease}
    .btn-press:active{transform:scale(.96)}
    
    /* Card entrance stagger */
    .stagger-1{animation-delay:.05s}
    .stagger-2{animation-delay:.1s}
    .stagger-3{animation-delay:.15s}
    .stagger-4{animation-delay:.2s}
    
    /* ===== MOBILE OPTIMIZATION ===== */
    @media (max-width: 768px) {
      /* Reduce cloud sizes on mobile */
      .c1,.c2,.c3,.c4,.c5,.c6,.c7,.c8,.c9{
        width:250px!important;
        height:100px!important;
      }
      
      /* Optimize toast for mobile */
      .toast-enter{
        min-width:280px!important;
        max-width:calc(100vw - 32px)!important;
        font-size:14px!important;
        padding:12px 16px!important;
      }
      
      /* Smaller glass cards on mobile */
      .glass-strong{
        padding:16px!important;
      }
      
      /* Adjust animations for mobile */
      .hover-lift:active{
        transform:translateY(-2px) scale(1.005);
      }
      
      /* Better button sizing for touch */
      button{
        min-height:44px;
        min-width:44px;
      }
      
      /* Optimize text sizing */
      .text-base{font-size:15px!important}
      .text-sm{font-size:13px!important}
      .text-xs{font-size:11px!important}
    }
    
    @media (max-width: 640px) {
      /* Even smaller on phones */
      body{
        font-size:14px;
      }
      
      /* Reduce header size */
      h1,h2,h3{
        font-size:1.25rem!important;
      }
      
      /* Stack buttons vertically on small screens */
      .flex-wrap{
        flex-direction:column!important;
        width:100%;
      }
      .flex-wrap > button{
        width:100%;
      }
      
      /* Full width inputs */
      input[type="file"],
      textarea,
      select{
        font-size:16px!important; /* Prevents zoom on iOS */
      }
      
      /* Adjust toast position for mobile */
      .fixed.top-20{
        top:70px!important;
        right:8px!important;
        left:8px!important;
      }
    }
    
    /* Landscape phone optimization */
    @media (max-width: 896px) and (orientation: landscape) {
      .sky,.sky-dim,.cloud{
        display:none; /* Hide animations in landscape for better performance */
      }
      body{
        background:#0b0f14;
      }
    }
    
    /* Touch-friendly improvements */
    @media (hover: none) and (pointer: coarse) {
      /* Better tap targets */
      button, a, input[type="button"]{
        min-height:48px;
        padding:12px 20px;
      }
      
      /* Remove glass hover effect on touch */
      .glass-hover:hover{
        transform:none;
        box-shadow:0 10px 30px rgba(0,0,0,.3);
      }
      
      /* Disable hover scale on touch devices */
      *:hover{
        transform:none!important;
      }
    }
</style>
  <link rel="preconnect" href="https://unpkg.com">
  <link rel="preconnect" href="https://cdn.tailwindcss.com">
  <link rel="icon" type="image/png" href="whistel_logo_top_right_2048.png">
  <!-- Lucide Icons -->
  <script src="https://unpkg.com/lucide@latest"></script>
  <!-- EXIF Reader for metadata scrubbing -->
  <script src="https://cdn.jsdelivr.net/npm/exifreader@4.14.1/dist/exif-reader.js"></script>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState } = React;
    // Project constants
    const CONTRACT_ADDRESS = '6Hb2xgEhyN9iVVH3cgSxYjfN774ExzgiCftwiWdjpump';

    // ---------- small helpers ----------
    const enc = new TextEncoder();
    const dec = new TextDecoder();
    const hex = (b) => Array.from(b).map((x) => x.toString(16).padStart(2, "0")).join("");
    // robust base64 helpers (URL-safe tolerant + large arrays)
    function safeAtob(str){
      let s = String(str||'');
      s = s.replace(/\s+/g,'').replace(/-/g,'+').replace(/_/g,'/');
      while (s.length % 4) s += '=';
      return atob(s);
    }
    function b64(u8){
      let binary = '';
      const CHUNK = 0x8000;
      for (let i=0;i<u8.length;i+=CHUNK){
        const sub = u8.subarray(i, i+CHUNK);
        binary += String.fromCharCode.apply(null, sub);
      }
      return btoa(binary);
    }
    function ub64(s){
      const bin = safeAtob(s);
      const out = new Uint8Array(bin.length);
      for (let i=0;i<bin.length;i++) out[i] = bin.charCodeAt(i);
      return out;
    }
    function textToB64(str){ return b64(new TextEncoder().encode(str)); }
    function b64ToText(s){ return new TextDecoder().decode(ub64(s)); }

    // Ensure Buffer polyfill for web3 internals in browser
    async function ensureBuffer(){
      if (!window.Buffer){
        try{
          const m = await import('https://esm.sh/buffer@6.0.3?bundle');
          window.Buffer = m.Buffer;
        }catch(e){ /* ignore; some environments already polyfill */ }
      }
    }

    // RPC defaults (hidden in UI; configurable via localStorage keys rpcHttpUrl / rpcWsUrl)
    const DEFAULT_RPC_HTTP = 'https://rpc-mainnet.solanatracker.io/?api_key=4f442388-ae6f-41ba-a9c4-30d3ff2ee2a0';
    const DEFAULT_RPC_WS   = 'wss://rpc-mainnet.solanatracker.io/?api_key=4f442388-ae6f-41ba-a9c4-30d3ff2ee2a0';
    function getRpcUrls(){
      try{
        const http = (localStorage.getItem('rpcHttpUrl') || DEFAULT_RPC_HTTP).trim();
        const ws = (localStorage.getItem('rpcWsUrl') || '').trim();
        return { http, ws };
      }catch{ return { http: DEFAULT_RPC_HTTP, ws: '' }; }
    }

    // Short, domain-like code for hashes (Base32 RFC4648, lowercase, dotted groups)
    function toBase32(u8){
      const alphabet = 'abcdefghijklmnopqrstuvwxyz234567';
      let out = '';
      let bits = 0, value = 0;
      for (let i=0;i<u8.length;i++){
        value = (value << 8) | u8[i];
        bits += 8;
        while (bits >= 5){
          out += alphabet[(value >>> (bits - 5)) & 31];
          bits -= 5;
        }
      }
      if (bits > 0){ out += alphabet[(value << (5 - bits)) & 31]; }
      return out;
    }
    function fromBase32(str){
      const alphabet = 'abcdefghijklmnopqrstuvwxyz234567';
      const map = Object.create(null);
      for (let i=0;i<alphabet.length;i++){ map[alphabet[i]] = i; }
      let bits = 0, value = 0, out = [];
      for (const ch of str.toLowerCase()){
        if (!(ch in map)) throw new Error('invalid base32');
        value = (value << 5) | map[ch];
        bits += 5;
        if (bits >= 8){
          out.push((value >>> (bits - 8)) & 255);
          bits -= 8;
        }
      }
      return new Uint8Array(out);
    }
    function formatShortCode(bytes){
      const b32 = toBase32(bytes).toLowerCase();
      return 'whis.' + b32.match(/.{1,4}/g).join('.');
    }
    function parseHashOrCode(input){
      const t = (input||'').trim().toLowerCase();
      if (/^[0-9a-f]{64}$/.test(t)) return t; // hex
      const clean = t.replace(/^whis\./,'').replace(/\./g,'');
      if (/^[a-z2-7]+$/.test(clean)){
        const bytes = fromBase32(clean);
        return hex(bytes);
      }
      throw new Error('Enter 64-hex or a whis.xxxx short code');
    }

    async function sha256(bytes) {
      const h = await crypto.subtle.digest("SHA-256", bytes);
      return new Uint8Array(h);
    }

    // ---------- persistence helpers ----------
    function usePersistentState(key, defaultValue){
      const [value, setValue] = React.useState(() => {
        try{
          const raw = localStorage.getItem(key);
          return raw != null ? JSON.parse(raw) : defaultValue;
        }catch{ return defaultValue; }
      });
      React.useEffect(()=>{
        try{ localStorage.setItem(key, JSON.stringify(value)); }catch{}
      }, [key, value]);
      return [value, setValue];
    }

    const HISTORY_KEY = 'whistleHistory';
    const HISTORY_MAX = 50;
    function storageGetHistory(){
      try{ return JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]'); }catch{ return []; }
    }
    function storageSetHistory(list){
      try{ localStorage.setItem(HISTORY_KEY, JSON.stringify(list)); }catch{}
    }
    function storagePushHistory(entry){
      const list = storageGetHistory();
      list.unshift({ id: Math.random().toString(36).slice(2), ...entry });
      while (list.length > HISTORY_MAX) list.pop();
      storageSetHistory(list);
      try{ window.dispatchEvent(new CustomEvent('whHistory')); }catch{}
    }

    async function packBundle(text, files) {
      const pkg = { v: 1, createdAt: new Date().toISOString(), text, files: [] };
      let total = 0;
      for (const f of files) {
        const buf = new Uint8Array(await f.arrayBuffer());
        total += buf.length;
        if (total > 5 * 1024 * 1024 * 1024) throw new Error("Total evidence > 5 GB");
        pkg.files.push({ name: f.name, type: f.type, size: f.size, b64: b64(buf) });
      }
      const payload = enc.encode(JSON.stringify(pkg));
      const aesKeyRaw = crypto.getRandomValues(new Uint8Array(32));
      const aesKey = await crypto.subtle.importKey("raw", aesKeyRaw, "AES-GCM", false, ["encrypt", "decrypt"]);
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const ct = new Uint8Array(await crypto.subtle.encrypt({ name: "AES-GCM", iv }, aesKey, payload));
      return { pkgBytes: payload, aesKeyRaw, iv, ct };
    }

    async function unpackBundle(aesKeyRaw, iv, ct) {
      const aesKey = await crypto.subtle.importKey("raw", aesKeyRaw, "AES-GCM", false, ["decrypt"]);
      const plain = new Uint8Array(await crypto.subtle.decrypt({ name: "AES-GCM", iv }, aesKey, ct));
      return JSON.parse(dec.decode(plain));
    }

    function useToasts() {
      const [toasts, setToasts] = useState([]);
      
      useEffect(() => {
        if (window.lucide && toasts.length > 0) {
          setTimeout(() => window.lucide.createIcons(), 0);
        }
      }, [toasts]);
      
      function push(msg, tone = "default") {
        const id = Math.random().toString(36).slice(2);
        setToasts((t) => [...t, { id, msg, tone }]);
        setTimeout(() => setToasts((t) => t.filter((x) => x.id !== id)), 3500);
      }
      return { toasts, push };
    }

    // micro interaction: ripple on buttons
    function ripple(e){
      try{
        const btn = e.currentTarget;
        const rect = btn.getBoundingClientRect();
        const size = Math.max(rect.width, rect.height);
        const x = e.clientX - rect.left - size/2;
        const y = e.clientY - rect.top - size/2;
        const circle = document.createElement('span');
        circle.className = 'ripple';
        circle.style.width = circle.style.height = size + 'px';
        circle.style.left = x + 'px';
        circle.style.top = y + 'px';
        btn.appendChild(circle);
        setTimeout(()=>{ try{ circle.remove(); }catch{} }, 650);
      }catch{}
    }

    // ============ PRIVACY FEATURES ============
    
    // ===== STEGANOGRAPHY MODE =====
    // Hide encrypted data inside an innocent-looking image
    async function hideDataInImage(imageFile, secretText) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        const reader = new FileReader();
        
        reader.onload = (e) => {
          img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Add magic header for validation (WHIS = 01010111 01001000 01001001 01010011)
            const MAGIC = 'WHIS';
            const magicBinary = MAGIC.split('').map(c => 
              c.charCodeAt(0).toString(2).padStart(8, '0')
            ).join('');
            
            // Convert secret to binary
            const secretBinary = secretText.split('').map(c => 
              c.charCodeAt(0).toString(2).padStart(8, '0')
            ).join('');
            
            // Add length prefix (32 bits) and magic header
            const lengthBinary = secretBinary.length.toString(2).padStart(32, '0');
            const fullBinary = magicBinary + lengthBinary + secretBinary;
            
            // Check if image has enough capacity (use multiple channels for redundancy)
            const capacity = (data.length / 4) * 2; // Use 2 LSBs per pixel for better resilience
            if (fullBinary.length > capacity) {
              reject(new Error('Image too small for this message (need ~' + Math.ceil(fullBinary.length / capacity * img.width * img.height / 1000) + 'K pixels)'));
              return;
            }
            
            // Hide data in LSB of both RED and GREEN channels for redundancy
            for (let i = 0; i < fullBinary.length; i++) {
              const bit = parseInt(fullBinary[i]);
              const pixelIndex = Math.floor(i / 2);
              const channel = (i % 2 === 0) ? 0 : 1; // Alternate between red(0) and green(1)
              data[pixelIndex * 4 + channel] = (data[pixelIndex * 4 + channel] & 0xFE) | bit;
            }
            
            ctx.putImageData(imageData, 0, 0);
            // Use maximum quality PNG to prevent data loss
            canvas.toBlob((blob) => {
              resolve(new File([blob], 'photo.png', { type: 'image/png' }));
            }, 'image/png', 1.0);
          };
          img.src = e.target.result;
        };
        
        reader.onerror = reject;
        reader.readAsDataURL(imageFile);
      });
    }
    
    async function extractDataFromImage(imageFile) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        const reader = new FileReader();
        
        reader.onload = (e) => {
          img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Extract magic header (first 32 bits from RED and GREEN channels)
            let magicBinary = '';
            for (let i = 0; i < 32; i++) {
              const pixelIndex = Math.floor(i / 2);
              const channel = (i % 2 === 0) ? 0 : 1;
              magicBinary += (data[pixelIndex * 4 + channel] & 1).toString();
            }
            
            // Verify magic header
            let magic = '';
            for (let i = 0; i < magicBinary.length; i += 8) {
              magic += String.fromCharCode(parseInt(magicBinary.substr(i, 8), 2));
            }
            
            if (magic !== 'WHIS') {
              reject(new Error('No Whistle hidden data found in this image. Make sure this image was created by Whistle Steganography.'));
              return;
            }
            
            // Extract length (next 32 bits)
            let lengthBinary = '';
            for (let i = 32; i < 64; i++) {
              const pixelIndex = Math.floor(i / 2);
              const channel = (i % 2 === 0) ? 0 : 1;
              lengthBinary += (data[pixelIndex * 4 + channel] & 1).toString();
            }
            const length = parseInt(lengthBinary, 2);
            
            if (length <= 0 || length > (data.length / 2) * 8) {
              reject(new Error('Data corrupted or invalid length'));
              return;
            }
            
            // Extract secret data
            let secretBinary = '';
            for (let i = 64; i < 64 + length; i++) {
              const pixelIndex = Math.floor(i / 2);
              const channel = (i % 2 === 0) ? 0 : 1;
              secretBinary += (data[pixelIndex * 4 + channel] & 1).toString();
            }
            
            // Convert binary back to text
            let secret = '';
            for (let i = 0; i < secretBinary.length; i += 8) {
              const byte = secretBinary.substr(i, 8);
              secret += String.fromCharCode(parseInt(byte, 2));
            }
            
            resolve(secret);
          };
          img.src = e.target.result;
        };
        
        reader.onerror = reject;
        reader.readAsDataURL(imageFile);
      });
    }

    // ===== SPREAD SPECTRUM STEGANOGRAPHY =====
    // Compression-resistant encoding using spread spectrum techniques
    
    // Helper: Simple hash function for seeding
    function simpleHash(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32-bit integer
      }
      return Math.abs(hash);
    }
    
    // Helper: Seeded pseudo-random number generator (LCG)
    function createSeededRandom(seed) {
      let state = seed;
      return function() {
        state = (state * 1664525 + 1013904223) >>> 0; // LCG algorithm
        return state / 4294967296; // Normalize to 0-1
      };
    }
    
    // Helper: Generate pseudo-random spreading sequence
    function generatePNSequence(password, bitIndex, length) {
      const seed = simpleHash(password + '|' + bitIndex);
      const rng = createSeededRandom(seed);
      const sequence = [];
      for (let i = 0; i < length; i++) {
        sequence.push(rng() > 0.5 ? 1 : -1);
      }
      return sequence;
    }
    
    // Helper: Select pixel indices for spreading
    function selectPixelIndices(bitIndex, spreadFactor, totalPixels, password) {
      const seed = simpleHash(password + '|idx|' + bitIndex);
      const rng = createSeededRandom(seed);
      const indices = [];
      const used = new Set();
      
      while (indices.length < spreadFactor) {
        const idx = Math.floor(rng() * totalPixels);
        if (!used.has(idx)) {
          used.add(idx);
          indices.push(idx);
        }
      }
      return indices;
    }
    
    // Spread Spectrum Encoder
    async function spreadSpectrumEncode(imageFile, secretText, password) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        const reader = new FileReader();
        
        reader.onload = (e) => {
          img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Parameters
            const SPREAD_FACTOR = 128; // Each bit spread across 128 pixels
            const STRENGTH = 3; // Signal strength (+/- 3)
            
            // Add header
            const MAGIC = 'WHSS'; // Spread Spectrum magic
            const fullMessage = MAGIC + secretText;
            
            // Convert to binary
            const messageBits = fullMessage.split('').map(c => 
              c.charCodeAt(0).toString(2).padStart(8, '0')
            ).join('');
            
            // Check capacity
            const totalPixels = data.length / 4;
            const requiredPixels = messageBits.length * SPREAD_FACTOR;
            if (requiredPixels > totalPixels) {
              reject(new Error(`Image too small. Need ${Math.ceil(requiredPixels/totalPixels)}x larger image or shorter message.`));
              return;
            }
            
            // Encode each bit
            for (let i = 0; i < messageBits.length; i++) {
              const bit = parseInt(messageBits[i]);
              const sequence = generatePNSequence(password, i, SPREAD_FACTOR);
              const pixelIndices = selectPixelIndices(i, SPREAD_FACTOR, totalPixels, password);
              
              for (let j = 0; j < SPREAD_FACTOR; j++) {
                const pixelIdx = pixelIndices[j];
                const dataIdx = pixelIdx * 4; // RGBA
                const seqVal = sequence[j];
                
                // Apply to red channel with spreading
                if (bit === 1) {
                  data[dataIdx] = Math.max(0, Math.min(255, data[dataIdx] + STRENGTH * seqVal));
                } else {
                  data[dataIdx] = Math.max(0, Math.min(255, data[dataIdx] - STRENGTH * seqVal));
                }
              }
            }
            
            ctx.putImageData(imageData, 0, 0);
            canvas.toBlob((blob) => {
              resolve(new File([blob], 'photo-ss.png', { type: 'image/png' }));
            }, 'image/png', 1.0);
          };
          img.src = e.target.result;
        };
        
        reader.onerror = reject;
        reader.readAsDataURL(imageFile);
      });
    }
    
    // Spread Spectrum Decoder
    async function spreadSpectrumDecode(imageFile, password) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        const reader = new FileReader();
        
        reader.onload = (e) => {
          img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Parameters (must match encoder)
            const SPREAD_FACTOR = 128;
            const totalPixels = data.length / 4;
            const MAX_MESSAGE_CHARS = 500; // Max chars to try
            const maxBits = MAX_MESSAGE_CHARS * 8;
            
            // Extract bits using correlation
            const extractedBits = [];
            for (let i = 0; i < maxBits; i++) {
              const sequence = generatePNSequence(password, i, SPREAD_FACTOR);
              const pixelIndices = selectPixelIndices(i, SPREAD_FACTOR, totalPixels, password);
              
              let correlation = 0;
              for (let j = 0; j < SPREAD_FACTOR; j++) {
                const pixelIdx = pixelIndices[j];
                const dataIdx = pixelIdx * 4;
                correlation += data[dataIdx] * sequence[j];
              }
              
              extractedBits.push(correlation > 0 ? '1' : '0');
            }
            
            // Convert bits to text
            let message = '';
            for (let i = 0; i < extractedBits.length; i += 8) {
              const byte = extractedBits.slice(i, i + 8).join('');
              const charCode = parseInt(byte, 2);
              if (charCode === 0) break; // Null terminator
              message += String.fromCharCode(charCode);
            }
            
            // Verify magic header
            if (!message.startsWith('WHSS')) {
              reject(new Error('No Spread Spectrum data found. The image may be corrupted or not encoded with Whistle.'));
              return;
            }
            
            // Remove magic header
            message = message.substring(4);
            
            // Clean up any trailing nulls or garbage
            const nullIndex = message.indexOf('\0');
            if (nullIndex > 0) {
              message = message.substring(0, nullIndex);
            }
            
            resolve(message);
          };
          img.src = e.target.result;
        };
        
        reader.onerror = reject;
        reader.readAsDataURL(imageFile);
      });
    }

    // ===== AUDIO STEGANOGRAPHY =====
    
    // Encode message into WAV audio file using LSB in audio samples
    async function hideDataInAudio(audioFile, secretText) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        
        reader.onload = async (e) => {
          try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const arrayBuffer = e.target.result;
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            // Get audio samples (use first channel)
            const channelData = audioBuffer.getChannelData(0);
            const samples = new Float32Array(channelData);
            
            // Add magic header
            const MAGIC = 'WHAU'; // Whistle Audio
            const fullMessage = MAGIC + secretText + '\0';
            
            // Convert message to binary
            const messageBits = fullMessage.split('').map(c => 
              c.charCodeAt(0).toString(2).padStart(8, '0')
            ).join('');
            
            // Check capacity (we can hide 1 bit per sample)
            if (messageBits.length > samples.length) {
              reject(new Error('Audio file too short for message. Need longer audio or shorter message.'));
              return;
            }
            
            // Encode bits into LSB of audio samples
            for (let i = 0; i < messageBits.length; i++) {
              const bit = parseInt(messageBits[i]);
              // Convert float to 16-bit integer, modify LSB, convert back
              let sample16 = Math.floor(samples[i] * 32768);
              sample16 = (sample16 & ~1) | bit; // Clear LSB and set new bit
              samples[i] = sample16 / 32768;
            }
            
            // Create new audio buffer with modified samples
            const newBuffer = audioContext.createBuffer(
              audioBuffer.numberOfChannels,
              audioBuffer.length,
              audioBuffer.sampleRate
            );
            newBuffer.copyToChannel(samples, 0);
            
            // Convert to WAV blob
            const wavBlob = audioBufferToWav(newBuffer);
            resolve(wavBlob);
          } catch (e) {
            reject(e);
          }
        };
        
        reader.onerror = reject;
        reader.readAsArrayBuffer(audioFile);
      });
    }
    
    // Extract hidden message from audio file
    async function extractDataFromAudio(audioFile) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        
        reader.onload = async (e) => {
          try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const arrayBuffer = e.target.result;
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            const channelData = audioBuffer.getChannelData(0);
            const samples = new Float32Array(channelData);
            
            // Extract bits from LSB
            let messageBits = '';
            for (let i = 0; i < Math.min(samples.length, 100000); i++) {
              const sample16 = Math.floor(samples[i] * 32768);
              const bit = sample16 & 1;
              messageBits += bit;
              
              // Try to decode every 8 bits
              if (messageBits.length % 8 === 0) {
                const chars = messageBits.match(/.{8}/g).map(b => String.fromCharCode(parseInt(b, 2)));
                const text = chars.join('');
                if (text.startsWith('WHAU')) {
                  // Found magic header, continue until null terminator
                  const nullIndex = text.indexOf('\0');
                  if (nullIndex > 0) {
                    resolve(text.substring(4, nullIndex));
                    return;
                  }
                }
              }
            }
            
            reject(new Error('No hidden message found in audio file.'));
          } catch (e) {
            reject(e);
          }
        };
        
        reader.onerror = reject;
        reader.readAsArrayBuffer(audioFile);
      });
    }
    
    // Helper: Convert AudioBuffer to WAV Blob
    function audioBufferToWav(buffer) {
      const length = buffer.length * buffer.numberOfChannels * 2;
      const arrayBuffer = new ArrayBuffer(44 + length);
      const view = new DataView(arrayBuffer);
      const channels = [];
      let offset = 0;
      let pos = 0;
      
      // Write WAV header
      const setUint16 = (data) => { view.setUint16(pos, data, true); pos += 2; };
      const setUint32 = (data) => { view.setUint32(pos, data, true); pos += 4; };
      
      setUint32(0x46464952); // "RIFF"
      setUint32(36 + length); // file length - 8
      setUint32(0x45564157); // "WAVE"
      setUint32(0x20746d66); // "fmt " chunk
      setUint32(16); // length = 16
      setUint16(1); // PCM
      setUint16(buffer.numberOfChannels);
      setUint32(buffer.sampleRate);
      setUint32(buffer.sampleRate * 2 * buffer.numberOfChannels);
      setUint16(buffer.numberOfChannels * 2);
      setUint16(16); // bits per sample
      setUint32(0x61746164); // "data" chunk
      setUint32(length);
      
      // Write interleaved audio data
      for (let i = 0; i < buffer.numberOfChannels; i++) {
        channels.push(buffer.getChannelData(i));
      }
      
      while (pos < arrayBuffer.byteLength) {
        for (let i = 0; i < buffer.numberOfChannels; i++) {
          let sample = Math.max(-1, Math.min(1, channels[i][offset]));
          sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
          view.setInt16(pos, sample, true);
          pos += 2;
        }
        offset++;
      }
      
      return new Blob([arrayBuffer], { type: 'audio/wav' });
    }
    
    // ===== VIDEO STEGANOGRAPHY =====
    
    // Encode message into video by hiding in frames
    async function hideDataInVideo(videoFile, secretText) {
      return new Promise((resolve, reject) => {
        const video = document.createElement('video');
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        video.onloadedmetadata = async () => {
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          
          const MAGIC = 'WHVI'; // Whistle Video
          const fullMessage = MAGIC + secretText + '\0';
          
          // Convert to binary
          const messageBits = fullMessage.split('').map(c => 
            c.charCodeAt(0).toString(2).padStart(8, '0')
          ).join('');
          
          const duration = video.duration;
          const fps = 30; // Assume 30 FPS
          const totalFrames = Math.floor(duration * fps);
          const bitsPerFrame = 100; // Hide 100 bits per frame
          const requiredFrames = Math.ceil(messageBits.length / bitsPerFrame);
          
          if (requiredFrames > totalFrames) {
            reject(new Error('Video too short for message. Need longer video or shorter message.'));
            return;
          }
          
          // Use MediaRecorder to create new video
          const stream = canvas.captureStream(fps);
          const mediaRecorder = new MediaRecorder(stream, { 
            mimeType: 'video/webm;codecs=vp9',
            videoBitsPerSecond: 5000000
          });
          
          const chunks = [];
          mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
          mediaRecorder.onstop = () => {
            const blob = new Blob(chunks, { type: 'video/webm' });
            resolve(blob);
          };
          
          mediaRecorder.start();
          
          let frameIndex = 0;
          let bitIndex = 0;
          
          const processFrame = () => {
            if (frameIndex >= totalFrames || bitIndex >= messageBits.length) {
              mediaRecorder.stop();
              return;
            }
            
            // Seek to frame
            video.currentTime = frameIndex / fps;
            
            video.onseeked = () => {
              ctx.drawImage(video, 0, 0);
              const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
              const data = imageData.data;
              
              // Hide bits in this frame
              let hiddenBits = 0;
              for (let i = 0; i < data.length && bitIndex < messageBits.length && hiddenBits < bitsPerFrame; i += 4) {
                const bit = parseInt(messageBits[bitIndex]);
                data[i] = (data[i] & ~1) | bit; // LSB of red channel
                bitIndex++;
                hiddenBits++;
              }
              
              ctx.putImageData(imageData, 0, 0);
              frameIndex++;
              
              setTimeout(processFrame, 1000 / fps);
            };
          };
          
          processFrame();
        };
        
        video.onerror = reject;
        video.src = URL.createObjectURL(videoFile);
        video.load();
      });
    }
    
    // Extract hidden message from video
    async function extractDataFromVideo(videoFile) {
      return new Promise((resolve, reject) => {
        const video = document.createElement('video');
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        video.onloadedmetadata = () => {
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          
          const duration = video.duration;
          const fps = 30;
          const totalFrames = Math.floor(duration * fps);
          const bitsPerFrame = 100;
          
          let messageBits = '';
          let frameIndex = 0;
          
          const processFrame = () => {
            if (frameIndex >= totalFrames) {
              reject(new Error('No hidden message found in video.'));
              return;
            }
            
            video.currentTime = frameIndex / fps;
            
            video.onseeked = () => {
              ctx.drawImage(video, 0, 0);
              const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
              const data = imageData.data;
              
              // Extract bits from this frame
              let extractedBits = 0;
              for (let i = 0; i < data.length && extractedBits < bitsPerFrame; i += 4) {
                const bit = data[i] & 1;
                messageBits += bit;
                extractedBits++;
                
                // Try to decode
                if (messageBits.length % 8 === 0) {
                  const chars = messageBits.match(/.{8}/g).map(b => String.fromCharCode(parseInt(b, 2)));
                  const text = chars.join('');
                  if (text.startsWith('WHVI')) {
                    const nullIndex = text.indexOf('\0');
                    if (nullIndex > 0) {
                      resolve(text.substring(4, nullIndex));
                      return;
                    }
                  }
                }
              }
              
              frameIndex++;
              processFrame();
            };
          };
          
          processFrame();
        };
        
        video.onerror = reject;
        video.src = URL.createObjectURL(videoFile);
        video.load();
      });
    }

    // 1. Metadata Scrubber - Remove EXIF and metadata from files
    async function scrubMetadata(file) {
      try {
        // For images - remove EXIF data
        if (file.type.startsWith('image/')) {
          const arrayBuffer = await file.arrayBuffer();
          const uint8Array = new Uint8Array(arrayBuffer);
          
          // Create a canvas to re-encode without metadata
          const img = new Image();
          const blob = new Blob([uint8Array], { type: file.type });
          const url = URL.createObjectURL(blob);
          
          return new Promise((resolve) => {
            img.onload = () => {
              const canvas = document.createElement('canvas');
              canvas.width = img.width;
              canvas.height = img.height;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0);
              
              canvas.toBlob((cleanBlob) => {
                URL.revokeObjectURL(url);
                resolve(new File([cleanBlob], file.name, { type: file.type }));
              }, file.type, 0.95);
            };
            img.src = url;
          });
        }
        
        // For PDFs and other files - strip metadata headers
        if (file.type === 'application/pdf') {
          // Basic PDF metadata removal (simplified)
          const arrayBuffer = await file.arrayBuffer();
          const uint8Array = new Uint8Array(arrayBuffer);
          // Return as-is with warning (full PDF scrubbing requires pdf-lib)
          return file;
        }
        
        // For other files, return as-is
        return file;
      } catch (e) {
        console.error('Metadata scrub failed:', e);
        return file; // Return original if scrubbing fails
      }
    }


    function GlassCard({ title, subtitle, children, className = "" }) {
      const ref = useRef(null);
      const [tilt, setTilt] = useState('');
      function onMove(e){
        const el = ref.current; if(!el) return;
        const r = el.getBoundingClientRect();
        const px = (e.clientX - r.left) / r.width; // 0..1
        const py = (e.clientY - r.top) / r.height; // 0..1
        const rx = (py - .5) * 6; // tilt X
        const ry = (px - .5) * -6; // tilt Y
        setTilt(`perspective(900px) rotateX(${rx}deg) rotateY(${ry}deg)`);
      }
      function onLeave(){ setTilt(''); }
      return (
        <section ref={ref} onMouseMove={onMove} onMouseLeave={onLeave}
          className={`relative rounded-2xl border border-white/10 backdrop-blur-xl p-5 shadow-xl shadow-black/30 glass-hover will-change-transform ${className} glass-strong`}
          style={{ transform: tilt }}>
          <div className="mb-3">
            <h3 className="text-lg font-semibold text-white/90">{title}</h3>
            {subtitle && <p className="text-xs text-white/50">{subtitle}</p>}
  </div>
          {children}
        </section>
      );
    }

    function SectionHeader() {
      return (
        <header className="flex items-center justify-between border-b border-white/10 pb-3 fade-up flex-wrap gap-3">
          <div className="flex items-center gap-3 min-w-0 flex-1">
            <div className="relative h-9 w-9 shrink-0 rounded-xl overflow-hidden border border-white/20 float-slow bg-white/5 hover:scale-110 transition-transform">
              <img src="whistel_logo_top_right_2048.png" alt="Whistle" className="absolute inset-0 h-full w-full object-contain"/>
               {!walletStore.pubkey && <span className="absolute inset-0 rounded-xl bg-cyan-400/20 animate-ping pulse-glow" />}
    </div>
      <div className="min-w-0 flex-1">
              <div className="text-white font-semibold text-base sm:text-lg">Whistle</div>
              <div className="text-xs text-white/50 hidden sm:block">P2P encrypted tips • Solana proof</div>
              <div className="mt-1 flex items-center gap-2 text-[11px] text-white/60">
                <span className="font-mono truncate max-w-[28ch] sm:max-w-[42ch]" title={CONTRACT_ADDRESS}>{CONTRACT_ADDRESS}</span>
                <button onClick={async()=>{ try{ await navigator.clipboard.writeText(CONTRACT_ADDRESS); alert('CA copied'); }catch{} }} className="rounded-md bg-white/10 hover:bg-white/20 border border-white/10 px-2 py-[2px] text-white/80 btn-press shrink-0">Copy</button>
      </div>
      </div>
    </div>
          <WalletConnectButton />
</header>
      );
    }

    // simple wallet event store
    const walletStore = { pubkey: null, setPub: () => {} };

    function WalletConnectButton() {
      const [label, setLabel] = useState("Connect Phantom");
      useEffect(() => {
        walletStore.setPub = (pk) => setLabel(pk ? `Connected: ${pk.slice(0, 4)}…` : "Connect Phantom");
      }, []);
      return (
        <button
          className="rounded-xl bg-cyan-500/80 hover:bg-cyan-400 text-black font-semibold px-4 py-2 transition-colors btn-ripple active:scale-[.98]"
          onClick={async (e) => {
            ripple(e);
            if (!window?.solana?.isPhantom) {
              alert("Install Phantom to post Solana Memo (optional). Other features work without it.");
              return;
            }
            try {
              const r = await window.solana.connect();
              walletStore.pubkey = r.publicKey.toBase58();
              walletStore.setPub(walletStore.pubkey);
            } catch (e) {}
          }}
        >
          {label}
        </button>
      );
    }

    function StepPills({ step, setStep }) {
      const tabs = [
        { id: "home", label: "Home" },
        { id: "webrtc", label: "Transfer" },
        { id: "image-stego", label: "🎭 Image" },
        { id: "audio-stego", label: "🎵 Audio" },
        { id: "video-stego", label: "🎥 Video" },
        { id: "swap", label: "Swap" },
      ];
      return (
        <div className="flex flex-wrap gap-2 md:hidden">
          {tabs.map((t) => (
            <button
              key={t.id}
              onClick={() => setStep(t.id)}
              className={`rounded-full px-4 py-2 text-sm border ${
                step === t.id
                  ? "border-cyan-400 bg-cyan-400/20 text-cyan-200"
                  : "border-white/10 bg-white/[0.03] text-white/70 hover:bg-white/[0.06]"
              }`}
            >
              {t.label}
            </button>
          ))}
      </div>
      );
    }

    // Sidebar navigation
    function Sidebar({ step, setStep }){
      const items = [
        { id:'home',    label:'Home', icon:'home' },
        { id:'webrtc',    label:'WebRTC Transfer', icon:'radio' },
        { id:'image-stego', label:'🎭 Image Stego', icon:'image' },
        { id:'audio-stego', label:'🎵 Audio Stego', icon:'music' },
        { id:'video-stego', label:'🎥 Video Stego', icon:'video' },
        { id:'swap', label:'Privacy Swap', icon:'shuffle' },
      ];
      
      useEffect(()=>{
        if(window.lucide) window.lucide.createIcons();
      },[step]);
      
      return (
        <aside className="hidden md:block w-[260px] shrink-0 scale-in">
          <div className="rounded-3xl border border-white/10 p-4 sticky top-4 panel-strong">
            <nav className="space-y-2">
              {items.map((x,i)=> (
                <button key={x.id} onClick={()=>setStep(x.id)}
                  className={`w-full flex items-center gap-3 rounded-xl px-3 py-3 border text-sm transition-all btn-press ${step===x.id
                    ? 'border-cyan-400/60 bg-cyan-400/15 text-cyan-100 scale-in'
                    : 'border-white/10 bg-white/[0.03] text-white/80 hover:bg-white/[0.07] hover:scale-[1.02]'}
                  stagger-${i+1}`}>
                  <i data-lucide={x.icon} className="w-5 h-5"></i>
                  {x.label}
                </button>
              ))}
            </nav>
      </div>
        </aside>
      );
    }

    // Home landing
    function Home({ setStep }){
      useEffect(()=>{
        if(window.lucide) window.lucide.createIcons();
      },[]);
      
      return (
        <div className="space-y-4">
          <div className="fade-up">
            <GlassCard title="Welcome to Whistle" subtitle="Private, peer‑to‑peer tips with on‑chain proof">
              <p className="text-white/70 text-sm">Two roles. One secure hand‑off. Stream the encrypted bundle directly from sender to receiver. Only the bundle hash is posted to Solana as public proof.</p>
            </GlassCard>
    </div>
          <div className="grid lg:grid-cols-2 gap-4 fade-up-2">
            <div className="step-card hover-lift slide-in-left">
              <div className="flex items-center gap-2 text-gray-900 font-semibold mb-3">
                <div className="flex items-center justify-center w-10 h-10 rounded-xl bg-gradient-to-br from-cyan-400 to-cyan-600">
                  <i data-lucide="send" className="w-6 h-6 text-white"></i>
                </div>
                <span>Sender — real example</span>
              </div>
              <ul className="text-sm text-gray-800 space-y-1 list-disc list-inside">
                <li>Write: "Evidence of bid‑rigging in Q3." Attach <em>report.pdf</em> and <em>video.mp4</em>.</li>
                <li>Click <strong>Generate Offer</strong> → share Offer with the receiver.</li>
                <li>Paste their Answer → <strong>Connect</strong> → <strong>Send</strong>.</li>
                <li>App posts memo with hash, e.g. <span className="font-mono">whis.4f2c.abcd…</span></li>
              </ul>
              <div className="mt-2">
                <div className="mini-code font-mono text-xs text-gray-700 shimmer-bg">OFFER: eyJ0eXAiOiJ... (copy, paste to receiver)</div>
              </div>
              <div className="mt-3">
                <button onClick={()=>setStep('webrtc')} className="flex items-center gap-2 rounded-xl bg-cyan-500/80 hover:bg-cyan-400 text-black font-semibold px-4 py-2 btn-press">
                  <i data-lucide="arrow-right" className="w-5 h-5"></i>
                  Start Transfer
                </button>
              </div>
            </div>
            <div className="step-card hover-lift slide-in-right">
              <div className="flex items-center gap-2 text-gray-900 font-semibold mb-3">
                <div className="flex items-center justify-center w-10 h-10 rounded-xl bg-gradient-to-br from-purple-400 to-purple-600">
                  <i data-lucide="download" className="w-6 h-6 text-white"></i>
                </div>
                <span>Receiver — real example</span>
              </div>
              <ul className="text-sm text-gray-800 space-y-1 list-disc list-inside">
                <li>Paste Offer → click <strong>Generate Answer</strong> → send it back.</li>
                <li>When connected, the encrypted bundle streams; it decrypts locally.</li>
                <li>Download <em>report.pdf</em>, preview <em>video.mp4</em>, view the computed hash.</li>
                <li>Optionally post your own memo with the same hash.</li>
              </ul>
              <div className="mt-2">
                <div className="mini-code font-mono text-xs text-gray-700 shimmer-bg">ANSWER: eyJhbGciOiJ... (copy, send back to sender)</div>
              </div>
              <div className="mt-3">
                <button onClick={()=>setStep('webrtc')} className="flex items-center gap-2 rounded-xl bg-white/15 hover:bg-white/25 text-gray-900 font-semibold px-4 py-2 border border-white/10 btn-press">
                  <i data-lucide="arrow-right" className="w-5 h-5"></i>
                  Start Transfer
                </button>
              </div>
            </div>
          </div>
          <div className="fade-up-3">
            <GlassCard title="Why it's safe" subtitle="Short & direct">
              <div className="grid md:grid-cols-3 gap-3 text-sm text-white/80">
                <div className="step-card scale-in stagger-1 flex items-center gap-2">
                  <i data-lucide="lock" className="w-5 h-5 text-cyan-400"></i>
                  <span>End‑to‑end: AES‑GCM payload, RSA‑OAEP key wrapping.</span>
                </div>
                <div className="step-card scale-in stagger-2 flex items-center gap-2">
                  <i data-lucide="share-2" className="w-5 h-5 text-purple-400"></i>
                  <span>P2P stream: no file uploads; nothing stored server‑side.</span>
                </div>
                <div className="step-card scale-in stagger-3 flex items-center gap-2">
                  <i data-lucide="file-check" className="w-5 h-5 text-emerald-400"></i>
                  <span>Proof only: Solana memo posts just the SHA‑256 hash.</span>
                </div>
      </div>
            </GlassCard>
      </div>
    </div>
      );
    }

    function Onboarding({ setStep }) {
      const [open, setOpen] = useState(true);
      if (!open) return null;
      return (
        <div className="fixed inset-0 z-50 grid place-items-center bg-black/70 backdrop-blur">
          <div className="max-w-3xl w-[92%] rounded-3xl border border-white/10 bg-gradient-to-b from-white/[0.08] to-white/[0.03] p-6 text-white shadow-2xl">
            <h2 className="text-xl font-semibold mb-2">Choose your role to get started</h2>
            <div className="grid md:grid-cols-2 gap-4 mt-3">
              <div className="rounded-2xl border border-white/10 bg-white/[0.04] p-4">
                <h3 className="font-semibold text-white/90">Receiver</h3>
                <ul className="text-sm text-white/70 list-disc list-inside space-y-1 mt-1">
                  <li>Paste Offer</li>
                  <li>Generate Answer and send it back</li>
                  <li>Receive and decrypt tip</li>
                </ul>
                <button onClick={() => { setStep('receive'); setOpen(false); }} className="mt-3 w-full rounded-xl bg-cyan-500/80 hover:bg-cyan-400 text-black font-semibold px-4 py-2">I'm the Receiver</button>
    </div>
              <div className="rounded-2xl border border-white/10 bg-white/[0.04] p-4">
                <h3 className="font-semibold text-white/90">Sender</h3>
                <ul className="text-sm text-white/70 list-disc list-inside space-y-1 mt-1">
                  <li>Write tip + attach files</li>
                  <li>Generate Offer and share it</li>
                  <li>Paste Answer • Connect • Send</li>
                </ul>
                <button onClick={() => { setStep('send'); setOpen(false); }} className="mt-3 w-full rounded-xl bg-white/15 hover:bg-white/25 text-white font-semibold px-4 py-2 border border-white/10">I'm the Sender</button>
    </div>
      </div>
      </div>
    </div>
      );
    }

    // OpSec Checklist Modal
    function OpSecChecklist({ open, onClose, onConfirm }) {
      const [checks, setChecks] = useState({
        vpn: false,
        metadata: false,
        personal: false,
        tor: false
      });
      
      useEffect(()=>{
        if(window.lucide) window.lucide.createIcons();
      },[open]);
      
      if (!open) return null;
      
      const allChecked = Object.values(checks).filter(v => v).length >= 3; // At least 3 required
      
      return (
        <div className="fixed inset-0 z-50 grid place-items-center bg-black/80 backdrop-blur">
          <div className="max-w-xl w-[92%] rounded-3xl border border-white/10 bg-gradient-to-b from-white/[0.08] to-white/[0.03] p-6 text-white shadow-2xl scale-in">
            <div className="flex items-center gap-2 mb-3">
              <i data-lucide="shield-alert" className="w-6 h-6 text-yellow-400"></i>
              <h2 className="text-xl font-semibold">Security Checklist</h2>
    </div>
            <p className="text-sm text-white/70 mb-4">Before sending, confirm you've taken these privacy steps:</p>
            
            <div className="space-y-3">
              <label className="flex items-start gap-3 cursor-pointer p-3 rounded-xl hover:bg-white/5 transition">
                <input type="checkbox" checked={checks.vpn} onChange={(e)=>setChecks({...checks, vpn: e.target.checked})} className="mt-1 w-4 h-4" />
                <div className="flex-1">
                  <div className="font-semibold text-white/90">Using VPN or Tor</div>
                  <div className="text-xs text-white/60">Hide your IP address from network observers</div>
    </div>
              </label>
              
              <label className="flex items-start gap-3 cursor-pointer p-3 rounded-xl hover:bg-white/5 transition">
                <input type="checkbox" checked={checks.metadata} onChange={(e)=>setChecks({...checks, metadata: e.target.checked})} className="mt-1 w-4 h-4" />
                <div className="flex-1">
                  <div className="font-semibold text-white/90">Files have metadata removed</div>
                  <div className="text-xs text-white/60">Use the "Scrub Metadata" button above</div>
    </div>
              </label>
              
              <label className="flex items-start gap-3 cursor-pointer p-3 rounded-xl hover:bg-white/5 transition">
                <input type="checkbox" checked={checks.personal} onChange={(e)=>setChecks({...checks, personal: e.target.checked})} className="mt-1 w-4 h-4" />
                <div className="flex-1">
                  <div className="font-semibold text-white/90">No personal info in message</div>
                  <div className="text-xs text-white/60">Names, dates, locations, or unique phrases removed</div>
</div>
              </label>
              
              <label className="flex items-start gap-3 cursor-pointer p-3 rounded-xl hover:bg-white/5 transition">
                <input type="checkbox" checked={checks.tor} onChange={(e)=>setChecks({...checks, tor: e.target.checked})} className="mt-1 w-4 h-4" />
                <div className="flex-1">
                  <div className="font-semibold text-white/90">Verified receiver identity</div>
                  <div className="text-xs text-white/60">Confirm you're sending to the correct journalist/newsroom</div>
    </div>
              </label>
</div>

            <div className="flex gap-3 mt-5">
              <button onClick={onClose} className="flex-1 rounded-xl bg-white/10 hover:bg-white/15 text-white font-semibold px-4 py-2 border border-white/10 btn-press">Cancel</button>
              <button onClick={onConfirm} disabled={!allChecked} className="flex-1 rounded-xl bg-cyan-500/80 hover:bg-cyan-400 disabled:opacity-50 disabled:cursor-not-allowed text-black font-semibold px-4 py-2 btn-press">
                {allChecked ? 'Continue' : 'Check at least 3'}
              </button>
            </div>
          </div>
        </div>
      );
    }

    function Sender({ pushToast, onHashReady }) {
      const [tipText, setTipText] = usePersistentState('tipText', "");
      const fileRef = useRef(null);
      const [offerOut, setOfferOut] = useState("");
      const [answerIn, setAnswerIn] = usePersistentState('tipAnswerIn', "");
      const [connStatus, setConnStatus] = useState("Not connected");
      const [sending, setSending] = useState(false);
      const [prog, setProg] = useState(0);
      const peerRef = useRef(null);
      const dcRef = useRef(null);
      const [isDrag, setIsDrag] = useState(false);
      const [droppedFiles, setDroppedFiles] = useState([]);
      const [memoSig, setMemoSig] = useState("");
      const [shortCode, setShortCode] = useState("");
      const [waitingForAnswer, setWaitingForAnswer] = useState(false);
      const [connecting, setConnecting] = useState(false);
      
      // Privacy features
      const [showOpSec, setShowOpSec] = useState(false);
      const [scrubbingMetadata, setScrubbingMetadata] = useState(false);
      const [stegoMode, setStegoMode] = useState(false);
      const [stegoImage, setStegoImage] = useState(null);
      const [stegoProcessing, setStegoProcessing] = useState(false);
      const stegoFileRef = useRef(null);
      
      useEffect(()=>{
        if(window.lucide) window.lucide.createIcons();
      });
      
      // Metadata scrubber handler
      async function handleScrubMetadata(){
        const files = fileRef.current?.files || [];
        const dropped = droppedFiles || [];
        const allFiles = [...files, ...dropped];
        
        if (allFiles.length === 0) { pushToast("Attach files first", "err"); return; }
        
        setScrubbingMetadata(true);
        try {
          const scrubbed = [];
          for (const file of allFiles) {
            const clean = await scrubMetadata(file);
            scrubbed.push(clean);
          }
          
          // Create new FileList (can't modify directly)
          const dt = new DataTransfer();
          scrubbed.forEach(f => dt.items.add(f));
          if (fileRef.current) fileRef.current.files = dt.files;
          setDroppedFiles([]);
          
          pushToast(`Metadata removed from ${scrubbed.length} file(s)`, "ok");
        } catch (e) {
          pushToast("Metadata scrubbing failed", "err");
        }
        setScrubbingMetadata(false);
      }
      
      // Steganography mode handler
      async function handleCreateStegoImage(){
        if (!stegoFileRef.current?.files?.[0]) {
          pushToast("Select a cover image first", "err");
          return;
        }
        if (!offerOut) {
          pushToast("Generate an Offer first", "err");
          return;
        }
        
        setStegoProcessing(true);
        try {
          const coverImage = stegoFileRef.current.files[0];
          const hiddenImage = await hideDataInImage(coverImage, offerOut);
          setStegoImage(hiddenImage);
          pushToast("✓ Offer hidden in image! Download and share.", "ok");
        } catch (e) {
          pushToast("Steganography failed: " + e.message, "err");
        }
        setStegoProcessing(false);
      }
      
      async function downloadStegoImage(){
        if (!stegoImage) return;
        const url = URL.createObjectURL(stegoImage);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'vacation-photo.png';
        a.click();
        URL.revokeObjectURL(url);
        pushToast("Image downloaded — share it anywhere!", "ok");
      }

      async function copyOffer(){
        try{ await navigator.clipboard.writeText(offerOut || ""); pushToast("Offer copied", "ok"); }catch(e){ pushToast("Copy failed", "err"); }
      }
      async function shareOffer(){
        try{
          if (!offerOut){ pushToast("Generate an Offer first", "err"); return; }
          const message = `Whistle Courier Offer (Tipster)\n\nPaste this in Newsroom → Step 1 (Paste Offer), click Generate Answer, and send the Answer back.\n\n${offerOut}`;
          if (navigator.share){
            await navigator.share({ title: 'Whistle Courier Offer', text: message });
            pushToast("Shared", "ok");
          } else {
            await navigator.clipboard.writeText(message);
            pushToast("Offer + instructions copied — share anywhere", "ok");
          }
        }catch(e){ pushToast("Share failed", "err"); }
      }
      async function pasteAnswer(){
        try{ const t = await navigator.clipboard.readText(); setAnswerIn(t || ""); if((t||"").trim()) setWaitingForAnswer(false); pushToast("Pasted from clipboard", "ok"); }catch(e){ pushToast("Paste failed", "err"); }
      }
      function resetSender(){
        try{ dcRef.current?.close?.(); }catch{}
        try{ peerRef.current?.close?.(); }catch{}
        setTipText(""); if (fileRef.current) fileRef.current.value="";
        setOfferOut(""); setAnswerIn(""); setConnStatus("Not connected"); setSending(false); setProg(0);
        setWaitingForAnswer(false); setConnecting(false);
        pushToast("Tipster reset", "ok");
      }

      async function makeOffer() {
        try {
          const pc = new RTCPeerConnection({ iceServers: [{ urls: ["stun:stun.l.google.com:19302"] }] });
          peerRef.current = pc;
          const dc = pc.createDataChannel("whistle", { ordered: true });
          dc.binaryType = "arraybuffer";
          dcRef.current = dc;
          dc.onopen = () => { setConnStatus("Connected"); setConnecting(false); };
          dc.onclose = () => { setConnStatus("Closed"); };
          pc.onicecandidate = (e) => { if (!e.candidate) setOfferOut(textToB64(JSON.stringify(pc.localDescription))); };
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          pushToast("Offer created. Copy to newsroom.", "ok");
          setWaitingForAnswer(true);
          setConnecting(false);
        } catch (e) {
          pushToast("Offer failed: " + (e.message || e), "err");
        }
      }

      async function acceptAnswer() {
        try {
          if (!peerRef.current) throw new Error("Create an Offer first");
          const ans = JSON.parse(b64ToText(answerIn.trim()));
          await peerRef.current.setRemoteDescription(new RTCSessionDescription(ans));
          setConnStatus("Connecting…");
          setConnecting(true);
        } catch (e) {
          pushToast("Accept failed: " + (e.message || e), "err");
        }
      }

      async function sendNow() {
        // Show OpSec checklist first
        setShowOpSec(true);
      }
      
      async function actualSend() {
        setShowOpSec(false);
        try {
          const dc = dcRef.current;
          if (!dc || dc.readyState !== "open") throw new Error("Not connected");
          const inputFiles = fileRef.current?.files || [];
          const files = [...inputFiles, ...droppedFiles];
          const { pkgBytes, aesKeyRaw, iv, ct } = await packBundle(tipText, files);
          const hash = await sha256(ct);
          const bundleHash = hex(hash);
          setShortCode(formatShortCode(hash));
          onHashReady(bundleHash);

          setSending(true); setProg(0);
          const header = JSON.stringify({ v: 1, iv: b64(iv), key: b64(aesKeyRaw), ctSize: ct.length });
          dc.send(new TextEncoder().encode(header));
          await new Promise((r) => setTimeout(r, 50));
          const chunk = 64 * 1024; let sent = 0;
          while (sent < ct.length) {
            const part = ct.slice(sent, Math.min(sent + chunk, ct.length));
            dc.send(part);
            sent += part.length;
            setProg(Math.round((sent * 100) / ct.length));
            await new Promise((r) => setTimeout(r, 0));
          }
          setSending(false);
          pushToast("Tip sent", "ok");
          storagePushHistory({ role:'tipster', kind:'sent', hash: bundleHash, short: formatShortCode(hash), at: new Date().toISOString() });

          // Immediately post memo (required)
          try{
            const { Connection, PublicKey, SystemProgram, Transaction, TransactionInstruction } = solanaWeb3;
            await ensureBuffer();
            if (!walletStore.pubkey){
              const r = await window.solana?.connect?.();
              if(!r) throw new Error("Wallet not connected");
              walletStore.pubkey = r.publicKey.toBase58();
              walletStore.setPub(walletStore.pubkey);
            }
            const { http: httpUrl, ws: wsUrl } = getRpcUrls();
            const conn = wsUrl ? new Connection(httpUrl, { commitment:'confirmed', wsEndpoint: wsUrl }) : new Connection(httpUrl, 'confirmed');
            const MEMO = new PublicKey("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr");
            const memoBuf = enc.encode("WHISTLE_HASH:" + bundleHash); // Uint8Array
            const ixMemo = new TransactionInstruction({ keys: [], programId: MEMO, data: memoBuf });
            const ixPing = SystemProgram.transfer({ fromPubkey: new PublicKey(walletStore.pubkey), toPubkey: new PublicKey(walletStore.pubkey), lamports: 0 });
    const tx = new Transaction().add(ixPing, ixMemo);
            tx.feePayer = new PublicKey(walletStore.pubkey);
    tx.recentBlockhash = (await conn.getLatestBlockhash()).blockhash;
    const signed = await window.solana.signTransaction(tx);
            const sig = await conn.sendRawTransaction(signed.serialize(), { skipPreflight: false });
    await conn.confirmTransaction(sig, 'confirmed');
            setMemoSig(sig);
            pushToast("Solana memo posted", "ok");
            storagePushHistory({ role:'tipster', kind:'memo', hash: bundleHash, short: formatShortCode(hash), sig, at: new Date().toISOString() });
          }catch(err){
            const msg = (err && err.message) ? err.message : String(err);
            pushToast("Memo failed: "+msg, "err");
          }
        } catch (e) {
          setSending(false);
          pushToast("Send failed: " + (e.message || e), "err");
        }
      }

      return (
        <>
          <OpSecChecklist open={showOpSec} onClose={()=>setShowOpSec(false)} onConfirm={actualSend} />
          
          <GlassCard title="Sender — Send" subtitle="Compose, connect, and send end-to-end encrypted">
            {/* Privacy Tools */}
            <div className="mb-4 p-3 rounded-xl bg-gradient-to-r from-yellow-500/10 to-orange-500/10 border border-yellow-400/20">
              <div className="flex items-center gap-2 mb-2">
                <i data-lucide="shield-check" className="w-5 h-5 text-yellow-400"></i>
                <h4 className="text-white/90 font-semibold text-sm">Privacy Tools</h4>
              </div>
              <div className="flex flex-wrap gap-2 mb-2">
                <button onClick={(e)=>{ ripple(e); handleScrubMetadata(); }} disabled={scrubbingMetadata} className="flex items-center gap-2 rounded-lg bg-cyan-500/20 hover:bg-cyan-500/30 text-cyan-200 text-xs font-semibold px-3 py-1.5 border border-cyan-400/30 btn-ripple">
                  <i data-lucide={scrubbingMetadata ? "loader" : "eraser"} className={`w-3 h-3 ${scrubbingMetadata ? 'animate-spin' : ''}`}></i>
                  {scrubbingMetadata ? 'Scrubbing...' : 'Scrub Metadata'}
                </button>
                <button onClick={(e)=>{ ripple(e); setStegoMode(!stegoMode); }} className={`flex items-center gap-2 rounded-lg ${stegoMode ? 'bg-purple-500/30 border-purple-400/50' : 'bg-purple-500/20 border-purple-400/30'} hover:bg-purple-500/30 text-purple-200 text-xs font-semibold px-3 py-1.5 border btn-ripple`}>
                  <i data-lucide="image" className="w-3 h-3"></i>
                  {stegoMode ? '✓ Steganography ON' : 'Steganography Mode'}
                </button>
              </div>
              
              {stegoMode && (
                <div className="mt-3 p-3 rounded-xl bg-purple-500/10 border border-purple-400/20 scale-in">
                  <div className="flex items-center gap-2 mb-2">
                    <i data-lucide="eye-off" className="w-4 h-4 text-purple-300"></i>
                    <h5 className="text-white/90 font-semibold text-xs">🎭 Covert Communication Mode</h5>
                  </div>
                  <p className="text-xs text-white/60 mb-2">
                    <strong>The offer will be hidden inside an image.</strong> Share it like a normal photo — no suspicious text codes needed!
                  </p>
                  <input ref={stegoFileRef} type="file" accept="image/*" className="w-full rounded-lg bg-white/[0.06] border border-white/10 p-2 text-xs mb-2" />
                  <div className="flex gap-2">
                    <button onClick={(e)=>{ ripple(e); handleCreateStegoImage(); }} disabled={stegoProcessing || !offerOut} className="flex items-center gap-2 rounded-lg bg-purple-500/30 hover:bg-purple-400/40 disabled:opacity-50 text-purple-100 text-xs font-semibold px-3 py-1.5 border border-purple-400/30 btn-ripple">
                      <i data-lucide={stegoProcessing ? "loader" : "wand-2"} className={`w-3 h-3 ${stegoProcessing ? 'animate-spin' : ''}`}></i>
                      {stegoProcessing ? 'Hiding...' : 'Create Stego Image'}
                    </button>
                    {stegoImage && (
                      <>
                        <button onClick={(e)=>{ ripple(e); downloadStegoImage(); }} className="flex items-center gap-2 rounded-lg bg-emerald-500/30 hover:bg-emerald-400/40 text-emerald-100 text-xs font-semibold px-3 py-1.5 border border-emerald-400/30 btn-ripple">
                          <i data-lucide="download" className="w-3 h-3"></i>
                          Download
                        </button>
                        <button onClick={(e)=>{ ripple(e); 
                          const url = URL.createObjectURL(stegoImage);
                          const preview = window.open('', '_blank');
                          preview.document.write(`<img src="${url}" style="max-width:100%;height:auto;" /><p style="font-family:sans-serif;padding:20px;">👆 Share this image via email, WhatsApp, Twitter, etc. It looks completely normal!</p>`);
                        }} className="flex items-center gap-2 rounded-lg bg-cyan-500/30 hover:bg-cyan-400/40 text-cyan-100 text-xs font-semibold px-3 py-1.5 border border-cyan-400/30 btn-ripple">
                          <i data-lucide="eye" className="w-3 h-3"></i>
                          Preview
                        </button>
                      </>
                    )}
                  </div>
                  {stegoImage && (
                    <div className="mt-3 p-2 rounded-lg bg-emerald-500/20 border border-emerald-400/30 text-xs text-emerald-100">
                      <div className="flex items-center gap-2 mb-1">
                        <i data-lucide="check-circle" className="w-4 h-4"></i>
                        <strong>Ready to share!</strong>
                      </div>
                      <p className="text-white/70">Send via: Email, WhatsApp, Telegram, Twitter DM, Instagram, Facebook, Discord, or any messaging app. The image looks 100% innocent — perfect cover!</p>
                    </div>
                  )}
                  {!offerOut && (
                    <p className="mt-2 text-xs text-yellow-300">⚠ Generate an Offer first (Step A below)</p>
                  )}
                </div>
              )}
              
              <p className="text-xs text-white/50 mt-2">
                <strong>Scrub Metadata:</strong> Removes EXIF/GPS data from images.
                <strong className="ml-2">Steganography:</strong> Hides Offer inside an innocent-looking image.
              </p>
            </div>
            
            <div className="grid md:grid-cols-2 gap-4">
              <div>
                <label className="text-xs text-white/60">Message (text)</label>
                <textarea value={tipText} onChange={(e) => setTipText(e.target.value)} rows={8} className="mt-1 w-full rounded-xl bg-white/[0.06] border border-white/10 p-3 outline-none focus:ring-2 focus:ring-cyan-400/40" placeholder="Describe the issue with verifiable details." />
              </div>
            <div onDragOver={(e)=>{e.preventDefault(); setIsDrag(true);}} onDragLeave={()=>setIsDrag(false)} onDrop={(e)=>{ e.preventDefault(); setIsDrag(false); const files = Array.from(e.dataTransfer.files||[]); setDroppedFiles(files); pushToast(files.length?`Added ${files.length} file(s)`:'No files', files.length?'ok':'err'); }} className={"rounded-xl p-2 "+(isDrag?"border-2 border-dashed border-cyan-400 bg-white/10":"")}>
              <label className="text-xs text-white/60">Attach evidence (≤ 5 GB total)</label>
              <input ref={fileRef} type="file" multiple className="mt-1 w-full rounded-xl bg-white/[0.06] border border-white/10 p-2" />
              <p className="text-xs text-white/50 mt-1">Nothing uploads; it streams directly to the newsroom over an encrypted data channel.</p>
              {droppedFiles.length>0 && (
                <div className="mt-2 text-xs text-white/70">
                  <div className="mb-1">Dropped files:</div>
                  <ul className="list-disc list-inside space-y-0.5">
                    {droppedFiles.map((f,i)=> <li key={i}>{f.name} ({Math.round(f.size/1024)} KB)</li>)}
                  </ul>
                  <button onClick={(e)=>{ ripple(e); setDroppedFiles([]); }} className="mt-2 rounded-xl bg-white/10 hover:bg-white/20 text-white px-3 py-1 border border-white/10 btn-ripple text-xs">Clear dropped</button>
                </div>
              )}
      </div>
    </div>

          <div className="my-4 h-px bg-white/10" />

          {stegoMode && offerOut && (
            <div className="mb-4 p-4 rounded-xl bg-gradient-to-r from-purple-500/20 to-pink-500/20 border-2 border-purple-400/40 scale-in">
              <div className="flex items-center gap-2 mb-2">
                <i data-lucide="shield-check" className="w-5 h-5 text-purple-300"></i>
                <h4 className="text-white/90 font-semibold">🎭 Steganography Mode Active</h4>
              </div>
              <p className="text-sm text-white/80">
                Your Offer is ready. <strong>Don't copy/paste the text below</strong> — instead, use the stego image above. 
                It's hidden inside an innocent-looking photo for maximum security.
              </p>
            </div>
          )}

          <div className="grid md:grid-cols-2 gap-4">
            <div>
              <h4 className="flex items-center gap-2 text-white/90 font-semibold mb-1">
                <i data-lucide="key" className="w-5 h-5 text-cyan-400"></i>
                Step A — Create Offer {stegoMode && '(for Stego Image)'}
              </h4>
              <div className="flex gap-2">
                <button onClick={(e)=>{ ripple(e); makeOffer(); }} className="flex items-center gap-2 rounded-xl bg-cyan-500/80 hover:bg-cyan-400 text-black font-semibold px-4 py-2 btn-ripple active:scale-[.98]">
                  <i data-lucide="plus-circle" className="w-4 h-4"></i>
                  Generate
                </button>
                {!stegoMode && (
                  <>
                    <button onClick={(e)=>{ ripple(e); copyOffer(); }} disabled={!offerOut} className="flex items-center gap-2 rounded-xl bg-white/10 hover:bg-white/20 disabled:opacity-50 text-white font-semibold px-4 py-2 border border-white/10 btn-ripple active:scale-[.98]">
                      <i data-lucide="copy" className="w-4 h-4"></i>
                      Copy
                    </button>
                    <button onClick={(e)=>{ ripple(e); shareOffer(); }} disabled={!offerOut} className="flex items-center gap-2 rounded-xl bg-white/10 hover:bg-white/20 disabled:opacity-50 text-white font-semibold px-4 py-2 border border-white/10 btn-ripple active:scale-[.98]">
                      <i data-lucide="share" className="w-4 h-4"></i>
                      Share
                    </button>
                  </>
                )}
              </div>
              {stegoMode ? (
                <p className="text-xs text-white/50 mt-1">Generated Offer will be hidden in the stego image above. <strong>Don't share this text directly.</strong></p>
              ) : (
                <p className="text-xs text-white/50 mt-1">Copy this text and send it to the receiver. They will respond with an Answer.</p>
              )}
              <textarea readOnly value={offerOut} rows={6} className={`mt-2 w-full rounded-xl ${stegoMode ? 'bg-black/30 opacity-50' : 'bg-black/50'} border border-white/10 p-3 font-mono text-xs`} placeholder={stegoMode ? 'Offer will be hidden in stego image...' : ''} />
              {waitingForAnswer && !answerIn.trim() && connStatus!=="Connected" && (
                <div className="mt-2 flex items-center gap-2 text-xs text-white/60 scale-in">
                  <span className="inline-block h-3 w-3 rounded-full border-2 border-white/30 border-t-cyan-400 animate-spin rotate-slow" />
                  <span className="pulse-glow">Waiting for newsroom Answer…</span>
                </div>
              )}
    </div>
            <div>
              <h4 className="flex items-center gap-2 text-white/90 font-semibold mb-1">
                <i data-lucide="message-square" className="w-5 h-5 text-purple-400"></i>
                Step B — Paste Answer
              </h4>
              <textarea value={answerIn} onChange={(e) => { setAnswerIn(e.target.value); if(e.target.value.trim()) setWaitingForAnswer(false); }} rows={6} className="w-full rounded-xl bg-white/[0.06] border border-white/10 p-3 font-mono text-xs" placeholder="Paste newsroom Answer here" />
              <div className="flex items-center gap-3 mt-2 flex-wrap">
                <button onClick={(e)=>{ ripple(e); pasteAnswer(); }} className="flex items-center gap-2 rounded-xl bg-white/10 hover:bg-white/20 text-white font-semibold px-3 py-2 border border-white/10 btn-ripple active:scale-[.98]">
                  <i data-lucide="clipboard" className="w-4 h-4"></i>
                  Paste
                </button>
                <button onClick={(e)=>{ ripple(e); acceptAnswer(); }} disabled={!answerIn.trim()} className="flex items-center gap-2 rounded-xl bg-white/15 hover:bg-white/25 disabled:opacity-50 text-white font-semibold px-4 py-2 border border-white/10 btn-ripple active:scale-[.98]">
                  <i data-lucide="plug" className="w-4 h-4"></i>
                  Connect
                </button>
                <button onClick={(e)=>{ ripple(e); resetSender(); }} className="flex items-center gap-2 rounded-xl bg-white/5 hover:bg-white/15 text-white font-semibold px-3 py-2 border border-white/10 btn-ripple active:scale-[.98]">
                  <i data-lucide="refresh-cw" className="w-4 h-4"></i>
                  Reset
                </button>
                <span className="flex items-center gap-1 text-xs text-white/60">
                  <i data-lucide="wifi" className="w-3 h-3"></i>
                  {connStatus}
                </span>
              </div>
              {connecting && connStatus!=="Connected" && (
                <div className="mt-2 flex items-center gap-2 text-xs text-white/60 scale-in">
                  <span className="inline-block h-3 w-3 rounded-full border-2 border-white/30 border-t-purple-400 animate-spin rotate-slow" />
                  <span className="pulse-glow">Connecting to newsroom…</span>
    </div>
              )}
    </div>
</div>

          <div className="mt-4">
            <button onClick={(e)=>{ ripple(e); sendNow(); }} className="flex items-center gap-2 justify-center rounded-xl bg-gradient-to-r from-cyan-400 to-purple-400 hover:from-cyan-300 hover:to-purple-300 text-black font-semibold px-6 py-3 disabled:opacity-60 btn-ripple btn-press shadow-lg hover:shadow-xl transition-all" disabled={connStatus !== "Connected" || sending}>
              <i data-lucide={sending ? "loader" : "rocket"} className={`w-5 h-5 ${sending ? 'animate-spin' : ''}`}></i>
              {sending ? "Sending…" : "Send Encrypted Tip"}
            </button>
            {sending && (
              <div className="mt-2 h-2 w-full rounded-full bg-white/10 overflow-hidden scale-in">
                <div className="h-2 progress-shine rounded-full transition-all" style={{ width: `${prog}%` }} />
              </div>
            )}
          </div>
          <div className="text-xs text-white/60 mt-2 space-y-1">
            <p>Short code: <span className="font-mono">{shortCode}</span></p>
            {memoSig && (
              <p>🧾 Memo: <a className="text-cyan-300" target="_blank" rel="noreferrer" href={`https://solscan.io/tx/${memoSig}`}>{memoSig}</a></p>
            )}
          </div>
          </GlassCard>
        </>
      );
    }

    function Receiver({ pushToast, onHashReady, setVerifyHash }) {
      const [offerIn, setOfferIn] = useState("");
      const [answerOut, setAnswerOut] = useState("");
      const [status, setStatus] = useState("Waiting…");
      const [prog, setProg] = useState(0);
      const [text, setText] = useState("");
      const [files, setFiles] = useState([]);
      const [hash, setHash] = useState("");
      const peerRef = useRef(null);
      const dcRef = useRef(null);
      
      // Self-destruct features
      const [selfDestructTime, setSelfDestructTime] = useState(24); // hours
      const [destructCountdown, setDestructCountdown] = useState(null);
      const destructTimerRef = useRef(null);
      
      // Steganography extraction
      const [extractingStegoImage, setExtractingStegoImage] = useState(false);
      const stegoExtractRef = useRef(null);
      
      useEffect(()=>{
        if(window.lucide) window.lucide.createIcons();
      });
      
      // Start self-destruct timer when content is received
      useEffect(() => {
        if (text && selfDestructTime > 0) {
          const destructTime = Date.now() + (selfDestructTime * 60 * 60 * 1000);
          setDestructCountdown(destructTime);
          
          destructTimerRef.current = setInterval(() => {
            const remaining = destructTime - Date.now();
            if (remaining <= 0) {
              setText("");
              setFiles([]);
              setHash("");
              clearInterval(destructTimerRef.current);
              setDestructCountdown(null);
              pushToast("Message self-destructed ✓", "ok");
            }
          }, 1000);
          
          return () => clearInterval(destructTimerRef.current);
        }
      }, [text, selfDestructTime]);

      async function pasteOffer(){
        try{ const t = await navigator.clipboard.readText(); setOfferIn(t || ""); pushToast("Pasted Offer", "ok"); }catch(e){ pushToast("Paste failed", "err"); }
      }
      async function copyAnswer(){
        try{ await navigator.clipboard.writeText(answerOut || ""); pushToast("Answer copied", "ok"); }catch(e){ pushToast("Copy failed", "err"); }
      }
      function resetReceiver(){
        try{ dcRef.current?.close?.(); }catch{}
        try{ peerRef.current?.close?.(); }catch{}
        if (destructTimerRef.current) clearInterval(destructTimerRef.current);
        setOfferIn(""); setAnswerOut(""); setStatus("Waiting…"); setProg(0); setText(""); setFiles([]); setHash(""); setDestructCountdown(null);
        pushToast("Newsroom reset", "ok");
      }
      
      async function extractFromStegoImage(){
        if (!stegoExtractRef.current?.files?.[0]) {
          pushToast("Select an image first", "err");
          return;
        }
        
        setExtractingStegoImage(true);
        try {
          const imageFile = stegoExtractRef.current.files[0];
          const extracted = await extractDataFromImage(imageFile);
          setOfferIn(extracted);
          pushToast("✓ Offer extracted from image!", "ok");
        } catch (e) {
          pushToast("Extraction failed: " + e.message, "err");
        }
        setExtractingStegoImage(false);
      }
      
      function getTimeRemaining(){
        if (!destructCountdown) return '';
        const remaining = destructCountdown - Date.now();
        if (remaining <= 0) return 'Expired';
        const hours = Math.floor(remaining / (1000 * 60 * 60));
        const minutes = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((remaining % (1000 * 60)) / 1000);
        return `${hours}h ${minutes}m ${seconds}s`;
      }

      async function makeAnswer() {
        try {
          const pc = new RTCPeerConnection({ iceServers: [{ urls: ["stun:stun.l.google.com:19302"] }] });
          peerRef.current = pc;
          pc.ondatachannel = (ev) => {
            const dc = ev.channel;
            dcRef.current = dc;
            dc.binaryType = "arraybuffer";
            let rcvAccum = [];
            let rcvExpect = 0;
            let rcvIV = null;
            let rcvKey = null;
            dc.onopen = () => setStatus("Connected");
            dc.onmessage = async (e) => {
              const buf = new Uint8Array(e.data);
              if (!rcvIV) {
                const meta = JSON.parse(new TextDecoder().decode(buf));
                rcvIV = ub64(meta.iv);
                rcvKey = ub64(meta.key);
                rcvExpect = meta.ctSize | 0;
                rcvAccum = [];
                setProg(0);
              } else {
                rcvAccum.push(buf);
                const sofar = rcvAccum.reduce((n, b) => n + b.length, 0);
                setProg(Math.round((sofar * 100) / rcvExpect));
                if (sofar >= rcvExpect) {
                  const ct = new Uint8Array(sofar);
                  let off = 0;
                  for (const b of rcvAccum) { ct.set(b, off); off += b.length; }
                  const pkg = await unpackBundle(rcvKey, rcvIV, ct);
                  setText(pkg.text || "(no text)");
                  setFiles(pkg.files || []);
                  const h = hex(await sha256(ct));
                  setHash(h);
                  setVerifyHash(h);
                  onHashReady(h);
                  setStatus("Received & decrypted");
                  pushToast("Received & decrypted", "ok");
                  storagePushHistory({ role:'newsroom', kind:'received', hash: h, short: formatShortCode(await sha256(ct)), at: new Date().toISOString() });
                }
              }
            };
          };
          pc.onicecandidate = (e) => { if (!e.candidate) setAnswerOut(textToB64(JSON.stringify(pc.localDescription))); };
          const offer = JSON.parse(b64ToText(offerIn.trim()));
          await pc.setRemoteDescription(new RTCSessionDescription(offer));
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          setStatus("Answer created. Send it back to tipster.");
          pushToast("Answer ready", "ok");
        } catch (e) {
          pushToast("Answer failed: " + (e.message || e), "err");
        }
      }

      return (
        <GlassCard title="Receiver — Receive" subtitle="Paste Offer, generate Answer, accept the stream">
          {/* Steganography Extraction */}
          <div className="mb-4 p-3 rounded-xl bg-gradient-to-r from-purple-500/10 to-pink-500/10 border border-purple-400/20">
            <div className="flex items-center gap-2 mb-2">
              <i data-lucide="image-plus" className="w-5 h-5 text-purple-400"></i>
              <h4 className="text-white/90 font-semibold text-sm">Extract Offer from Image</h4>
            </div>
            <p className="text-xs text-white/60 mb-2">If sender used steganography, upload the image to extract the hidden Offer.</p>
            <div className="flex gap-2 items-end">
              <div className="flex-1">
                <input ref={stegoExtractRef} type="file" accept="image/*" className="w-full rounded-lg bg-white/[0.06] border border-white/10 p-2 text-xs" />
              </div>
              <button onClick={(e)=>{ ripple(e); extractFromStegoImage(); }} disabled={extractingStegoImage} className="flex items-center gap-2 rounded-lg bg-purple-500/30 hover:bg-purple-400/40 text-purple-100 text-xs font-semibold px-3 py-2 border border-purple-400/30 btn-ripple">
                <i data-lucide={extractingStegoImage ? "loader" : "scan"} className={`w-3 h-3 ${extractingStegoImage ? 'animate-spin' : ''}`}></i>
                {extractingStegoImage ? 'Extracting...' : 'Extract Offer'}
              </button>
            </div>
          </div>
          
          {/* Self-Destruct Settings */}
          <div className="mb-4 p-3 rounded-xl bg-gradient-to-r from-orange-500/10 to-red-500/10 border border-orange-400/20">
            <div className="flex items-center gap-2 mb-2">
              <i data-lucide="timer" className="w-5 h-5 text-orange-400"></i>
              <h4 className="text-white/90 font-semibold text-sm">Self-Destruct Timer</h4>
            </div>
            <p className="text-xs text-white/60 mb-2">Messages will automatically delete after this time. No trace left.</p>
            <div className="flex items-center gap-3">
              <select value={selfDestructTime} onChange={(e)=>setSelfDestructTime(Number(e.target.value))} className="rounded-lg bg-white/[0.06] border border-white/10 p-2 text-xs text-white">
                <option value="0">Disabled</option>
                <option value="1">1 hour</option>
                <option value="6">6 hours</option>
                <option value="12">12 hours</option>
                <option value="24">24 hours (default)</option>
                <option value="72">3 days</option>
              </select>
              {destructCountdown && (
                <span className="text-xs text-orange-300 font-mono flex items-center gap-1">
                  <i data-lucide="clock" className="w-3 h-3"></i>
                  Deletes in: {getTimeRemaining()}
                </span>
              )}
            </div>
          </div>
          
          <div className="grid md:grid-cols-2 gap-4">
            <div>
              <h4 className="flex items-center gap-2 text-white/90 font-semibold mb-1">
                <i data-lucide="inbox" className="w-5 h-5 text-cyan-400"></i>
                Step 1 — Paste Offer
              </h4>
               <p className="text-xs text-white/50 mb-1">Paste the code the sender sent you. Then click <span className="text-white/70 font-semibold">Generate Answer</span> and send the Answer back to the sender.</p>
              <textarea value={offerIn} onChange={(e) => setOfferIn(e.target.value)} rows={6} className="w-full rounded-xl bg-white/[0.06] border border-white/10 p-3 font-mono text-xs" placeholder="Paste tipster Offer here (or extract from image above)" />
              <div className="flex gap-2 mt-2 flex-wrap">
                <button onClick={(e)=>{ ripple(e); pasteOffer(); }} className="flex items-center gap-2 rounded-xl bg-white/10 hover:bg-white/20 text-white font-semibold px-3 py-2 border border-white/10 btn-ripple active:scale-[.98]">
                  <i data-lucide="clipboard" className="w-4 h-4"></i>
                  Paste Offer
                </button>
                <button onClick={(e)=>{ ripple(e); makeAnswer(); }} className="flex items-center gap-2 rounded-xl bg-cyan-500/80 hover:bg-cyan-400 text-black font-semibold px-4 py-2 btn-ripple active:scale-[.98]">
                  <i data-lucide="plus-circle" className="w-4 h-4"></i>
                  Generate Answer
                </button>
              </div>
              <div className="flex gap-2 mt-2">
                <button onClick={(e)=>{ ripple(e); copyAnswer(); }} disabled={!answerOut} className="flex items-center gap-2 rounded-xl bg-white/10 hover:bg-white/20 disabled:opacity-50 text-white font-semibold px-3 py-2 border border-white/10 btn-ripple active:scale-[.98]">
                  <i data-lucide="copy" className="w-4 h-4"></i>
                  Copy Answer
                </button>
                <button onClick={(e)=>{ ripple(e); resetReceiver(); }} className="flex items-center gap-2 rounded-xl bg-white/5 hover:bg-white/15 text-white font-semibold px-3 py-2 border border-white/10 btn-ripple active:scale-[.98]">
                  <i data-lucide="refresh-cw" className="w-4 h-4"></i>
                  Reset
                </button>
              </div>
              <textarea readOnly value={answerOut} rows={6} className="mt-2 w-full rounded-xl bg-black/50 border border-white/10 p-3 font-mono text-xs" placeholder="Copy this Answer back to tipster" />
            </div>
            <div>
              <h4 className="flex items-center gap-2 text-white/90 font-semibold mb-1">
                <i data-lucide="activity" className="w-5 h-5 text-emerald-400"></i>
                Status
              </h4>
              <p className="flex items-center gap-2 text-xs text-white/60 pulse-glow">
                <i data-lucide="info" className="w-3 h-3"></i>
                {status}
              </p>
              <div className="mt-2 h-2 w-full rounded-full bg-white/10 overflow-hidden">
                <div className="h-2 progress-shine rounded-full transition-all" style={{ width: `${prog}%` }} />
              </div>
            </div>
          </div>

          <div className="my-4 h-px bg-white/10" />

           <div className="scale-in">
             <h4 className="flex items-center gap-2 text-white/90 font-semibold mb-1">
               <i data-lucide="file-text" className="w-5 h-5 text-emerald-400"></i>
               Decrypted Tip
             </h4>
             <pre className="font-mono text-xs bg-black/40 p-3 rounded-xl border border-white/10 min-h-[96px] whitespace-pre-wrap hover:border-cyan-400/20 transition-all">{text}</pre>
             <div className="mt-2 space-y-1">
               {files.map((x, i) => (
                 <a key={i} href={URL.createObjectURL(new Blob([ub64(x.b64)], { type: x.type || "application/octet-stream" }))} download={x.name} className="flex items-center gap-2 text-cyan-300 hover:text-cyan-200 text-sm hover:translate-x-1 transition-transform">
                   <i data-lucide="paperclip" className="w-4 h-4"></i>
                   Download {x.name} ({x.type || "file"})
                 </a>
               ))}
             </div>
             <p className="flex items-center gap-2 text-xs text-white/60 mt-2">
               <i data-lucide="hash" className="w-4 h-4"></i>
               Bundle hash: <span className="font-mono shimmer-bg">{hash}</span>
             </p>
           </div>
        </GlassCard>
      );
    }

    function VerifyMemo({ pushToast, verifyHash }) {
      const [hashIn, setHashIn] = useState(verifyHash || "");
      const [memoSig, setMemoSig] = useState("");
      const [hist, setHist] = useState(storageGetHistory());
      
      useEffect(()=>{
        if(window.lucide) window.lucide.createIcons();
      });
      useEffect(()=>{
        function onH(){ setHist(storageGetHistory()); }
        window.addEventListener('whHistory', onH);
        return ()=> window.removeEventListener('whHistory', onH);
      },[]);

      useEffect(() => { if (verifyHash) setHashIn(verifyHash); }, [verifyHash]);

      async function postMemo() {
        try {
          let hash;
          try{ hash = parseHashOrCode(hashIn); }
          catch{ throw new Error("Enter 64-hex or whis.xxxx short code"); }
          if (!walletStore.pubkey) {
            const r = await window.solana?.connect?.();
            if (!r) throw new Error("Wallet not connected");
            walletStore.pubkey = r.publicKey.toBase58();
            walletStore.setPub(walletStore.pubkey);
          }
          const { Connection, PublicKey, SystemProgram, Transaction, TransactionInstruction } = solanaWeb3;
          await ensureBuffer();
          const { http: httpUrl, ws: wsUrl } = getRpcUrls();
          const conn = wsUrl
            ? new Connection(httpUrl, { commitment: 'confirmed', wsEndpoint: wsUrl })
            : new Connection(httpUrl, 'confirmed');
          const MEMO = new PublicKey("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr");
          const memoBuf = enc.encode("WHISTLE_HASH:" + hash); // Uint8Array
          const ixMemo = new TransactionInstruction({ keys: [], programId: MEMO, data: memoBuf });
          const ixPing = SystemProgram.transfer({ fromPubkey: new PublicKey(walletStore.pubkey), toPubkey: new PublicKey(walletStore.pubkey), lamports: 0 });
    const tx = new Transaction().add(ixPing, ixMemo);
          tx.feePayer = new PublicKey(walletStore.pubkey);
    tx.recentBlockhash = (await conn.getLatestBlockhash()).blockhash;
    const signed = await window.solana.signTransaction(tx);
          const sig = await conn.sendRawTransaction(signed.serialize(), { skipPreflight: false });
          await conn.confirmTransaction(sig, "confirmed");
          setMemoSig(sig);
          pushToast("Memo posted", "ok");
        } catch (e) {
          const msg = (e && e.message) ? e.message : String(e);
          if (msg.includes('403')){
            pushToast("Memo failed: RPC access forbidden (403). Check custom RPC HTTP/WS.", "err");
          } else {
            pushToast("Memo failed: " + msg, "err");
          }
        }
      }

      return (
        <GlassCard title="Verify / Memo" subtitle="Post Solana Memo with the bundle hash (required)">
          <div className="grid md:grid-cols-2 gap-4">
            <div>
              <label className="text-xs text-white/60">Bundle hash (sha256 hex or short code)</label>
              <input value={hashIn} onChange={(e) => setHashIn(e.target.value)} placeholder="e.g., 4f2c… or whis.abcd.efgh…" className="mt-1 w-full rounded-xl bg-white/[0.06] border border-white/10 p-3 font-mono text-xs outline-none focus:ring-2 focus:ring-cyan-400/40" />

              <button onClick={postMemo} className="mt-3 rounded-xl bg-white/15 hover:bg-white/25 text-white font-semibold px-4 py-2 border border-white/10">Post Memo</button>
              {memoSig && (
                <p className="text-xs text-white/60 mt-2">🧾 Memo: <a className="text-cyan-300" target="_blank" rel="noreferrer" href={`https://solscan.io/tx/${memoSig}`}>{memoSig}</a></p>
              )}
            </div>
            <div className="text-xs text-white/70 space-y-2">
              <div className="flex items-center justify-between">
                <h4 className="text-white/90 font-semibold">History</h4>
                <button onClick={()=>{ setHistory([]); setHistory([]); setHistory([]); setHistory([]); setHistory([]); /* noop */ }} className="hidden" />
                <button onClick={()=>{ setHistory([]); setHistory([]); }} className="hidden" />
                <button onClick={()=>{ setHistory([]); }} className="hidden" />
              </div>
              <div className="rounded-xl bg-white/[0.04] border border-white/10 max-h-64 overflow-auto">
                {hist.length === 0 && <div className="p-3 text-white/50">No previous items.</div>}
                {hist.map((h)=> (
                  <div key={h.id} className="flex items-center justify-between px-3 py-2 border-b border-white/5">
                    <div className="min-w-0">
                      <div className="text-white/80 font-mono truncate">{h.short}</div>
                      <div className="text-white/40 text-[11px]">{h.kind} • {new Date(h.at).toLocaleString()}</div>
                    </div>
                    <div className="flex gap-2 ml-3 shrink-0">
                      <button onClick={async ()=>{ try{ await navigator.clipboard.writeText(h.short); pushToast('Copied short code','ok'); }catch{} }} className="rounded-md bg-white/10 hover:bg-white/20 text-white text-[11px] px-2 py-1 border border-white/10">Copy</button>
                      <button onClick={async ()=>{ try{ await navigator.clipboard.writeText(h.hash); pushToast('Copied hash','ok'); }catch{} }} className="rounded-md bg-white/10 hover:bg-white/20 text-white text-[11px] px-2 py-1 border border-white/10">Hash</button>
                    </div>
                  </div>
                ))}
              </div>
              <div className="flex gap-2">
                <button onClick={()=> setHist(storageGetHistory())} className="rounded-md bg-white/10 hover:bg-white/20 text-white text-[11px] px-2 py-1 border border-white/10">Refresh</button>
                <button onClick={()=>{ setHistory([]); setHistory([]); setHistory([]); setHistory([]); setHistory([]); }} className="hidden" />
                <button onClick={()=>{ setHistory([]); setHistory([]); }} className="hidden" />
                <button onClick={()=>{ setHistory([]); setHistory([]); }} className="hidden" />
                <button onClick={()=>{ setHistory([]); setHistory([]); }} className="hidden" />
                <button onClick={()=>{ setHistory([]); setHistory([]); }} className="hidden" />
                <button onClick={()=>{ setHistory([]); setHistory([]); }} className="hidden" />
                <button onClick={()=>{ storageSetHistory([]); setHist([]); }} className="rounded-md bg-rose-500/20 hover:bg-rose-500/30 text-rose-100 text-[11px] px-2 py-1 border border-rose-400/30">Clear (local)</button>
              </div>
            </div>
          </div>
        </GlassCard>
      );
    }

    // ===== STEGANOGRAPHY-ONLY COMMUNICATION SECTION =====
    
    function StegoSender({ pushToast }) {
      const [message, setMessage] = useState("");
      const [stegoImage, setStegoImage] = useState(null);
      const [processing, setProcessing] = useState(false);
      const [mode, setMode] = useState('spread'); // 'lsb' or 'spread' - default to spread for compression resistance
      const coverImageRef = useRef(null);
      
      useEffect(()=>{
        if(window.lucide) window.lucide.createIcons();
      });
      
      async function createStegoImage() {
        if (!message.trim()) {
          pushToast("Write a message first", "err");
          return;
        }
        if (!coverImageRef.current?.files?.[0]) {
          pushToast("Select a cover image", "err");
          return;
        }
        
        setProcessing(true);
        try {
          const coverImage = coverImageRef.current.files[0];
          let hiddenImage;
          
          if (mode === 'spread') {
            // Use empty string as default password for Spread Spectrum
            hiddenImage = await spreadSpectrumEncode(coverImage, message, '');
            pushToast("✓ Message hidden with Spread Spectrum! Compression-resistant.", "ok");
          } else {
            hiddenImage = await hideDataInImage(coverImage, message);
            pushToast("✓ Message hidden in image!", "ok");
          }
          
          setStegoImage(hiddenImage);
        } catch (e) {
          pushToast("Failed: " + e.message, "err");
        }
        setProcessing(false);
      }
      
      function downloadImage() {
        if (!stegoImage) return;
        const url = URL.createObjectURL(stegoImage);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'photo.png';
        a.click();
        URL.revokeObjectURL(url);
        pushToast("Image downloaded!", "ok");
      }
      
      function resetStegoSender() {
        setMessage("");
        setStegoImage(null);
        if (coverImageRef.current) coverImageRef.current.value = "";
        pushToast("Reset", "ok");
      }
      
      return (
        <GlassCard title="🎭 Steganography — Sender" subtitle="Hide your message inside an innocent-looking image">
          <div className="space-y-4">
            {/* Mode Selection */}
            <div className="p-3 rounded-xl bg-gradient-to-r from-cyan-500/10 to-purple-500/10 border border-cyan-400/20">
              <label className="text-sm text-white/80 font-semibold mb-2 block">Encoding Mode</label>
              <div className="grid grid-cols-2 gap-2">
                <button 
                  onClick={(e)=>{ ripple(e); setMode('lsb'); }}
                  className={`rounded-xl p-3 border transition-all btn-ripple ${mode === 'lsb' ? 'bg-cyan-500/30 border-cyan-400/50 text-white' : 'bg-white/[0.04] border-white/10 text-white/70 hover:bg-white/[0.08]'}`}
                >
                  <div className="flex items-center gap-2 mb-1">
                    <i data-lucide="zap" className="w-4 h-4"></i>
                    <span className="font-semibold text-sm">LSB (Fast)</span>
                  </div>
                  <p className="text-xs opacity-80">High capacity, email/Telegram only</p>
                </button>
                <button 
                  onClick={(e)=>{ ripple(e); setMode('spread'); }}
                  className={`rounded-xl p-3 border transition-all btn-ripple ${mode === 'spread' ? 'bg-purple-500/30 border-purple-400/50 text-white' : 'bg-white/[0.04] border-white/10 text-white/70 hover:bg-white/[0.08]'}`}
                >
                  <div className="flex items-center gap-2 mb-1">
                    <i data-lucide="shield" className="w-4 h-4"></i>
                    <span className="font-semibold text-sm">Spread Spectrum</span>
                  </div>
                  <p className="text-xs opacity-80">Compression-resistant, works on X/Instagram!</p>
                </button>
              </div>
              <p className="text-xs text-white/60 mt-2">
                💡 <strong>Spread Spectrum</strong> is recommended — it survives compression from social media apps!
              </p>
            </div>
            
            <div>
              <label className="text-sm text-white/80 font-semibold mb-2 block">Your Secret Message</label>
              <textarea 
                value={message} 
                onChange={(e) => setMessage(e.target.value)} 
                rows={6} 
                className="w-full rounded-xl bg-white/[0.06] border border-white/10 p-3 outline-none focus:ring-2 focus:ring-purple-400/40 text-white" 
                placeholder="Type your confidential message here..."
              />
              <p className="text-xs text-white/50 mt-1">
                This message will be invisible to anyone looking at the image.
                {mode === 'spread' && <span className="ml-2 text-purple-300 font-mono">{message.length} / ~500 chars</span>}
              </p>
            </div>
            
            <div>
              <label className="text-sm text-white/80 font-semibold mb-2 block">Cover Image</label>
              <input 
                ref={coverImageRef} 
                type="file" 
                accept="image/*" 
                className="w-full rounded-xl bg-white/[0.06] border border-white/10 p-3 text-sm file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-purple-500/30 file:text-purple-100 hover:file:bg-purple-500/40"
              />
              <p className="text-xs text-white/50 mt-1">
                {mode === 'spread' ? 'Larger images recommended (1000x1000+) for better compression resistance' : 'Choose any image: vacation photo, pet, landscape, meme, etc.'}
              </p>
            </div>
            
            <div className="flex gap-3 flex-wrap">
              <button 
                onClick={(e)=>{ ripple(e); createStegoImage(); }} 
                disabled={processing}
                className="flex items-center gap-2 rounded-xl bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-400 hover:to-pink-400 disabled:opacity-50 text-white font-semibold px-6 py-3 btn-ripple btn-press shadow-lg"
              >
                <i data-lucide={processing ? "loader" : "wand-2"} className={`w-5 h-5 ${processing ? 'animate-spin' : ''}`}></i>
                {processing ? "Hiding Message..." : "Create Stego Image"}
              </button>
              
              {stegoImage && (
                <>
                  <button 
                    onClick={(e)=>{ ripple(e); downloadImage(); }}
                    className="flex items-center gap-2 rounded-xl bg-emerald-500/80 hover:bg-emerald-400 text-white font-semibold px-6 py-3 btn-ripple btn-press"
                  >
                    <i data-lucide="download" className="w-5 h-5"></i>
                    Download Image
                  </button>
                  
                  <button 
                    onClick={(e)=>{ ripple(e); 
                      const url = URL.createObjectURL(stegoImage);
                      const preview = window.open('', '_blank');
                      preview.document.write(`
                        <html><head><title>Stego Image Preview</title></head>
                        <body style="margin:0;padding:20px;background:#111;color:#fff;font-family:sans-serif;">
                          <h2>✅ Your Steganography Image</h2>
                          <img src="${url}" style="max-width:100%;height:auto;border-radius:12px;box-shadow:0 10px 40px rgba(0,0,0,0.5);" />
                          <p>👆 This image looks completely normal, but contains your hidden message!</p>
                          <p>Share it via email, WhatsApp, Twitter, Instagram, or any messaging platform.</p>
                        </body></html>
                      `);
                    }}
                    className="flex items-center gap-2 rounded-xl bg-cyan-500/80 hover:bg-cyan-400 text-white font-semibold px-6 py-3 btn-ripple btn-press"
                  >
                    <i data-lucide="eye" className="w-5 h-5"></i>
                    Preview
                  </button>
                </>
              )}
              
              <button 
                onClick={(e)=>{ ripple(e); resetStegoSender(); }}
                className="flex items-center gap-2 rounded-xl bg-white/10 hover:bg-white/20 text-white font-semibold px-4 py-3 border border-white/10 btn-ripple btn-press"
              >
                <i data-lucide="refresh-cw" className="w-4 h-4"></i>
                Reset
              </button>
            </div>
            
            {stegoImage && (
              <div className={`mt-4 p-4 rounded-xl bg-gradient-to-r border scale-in ${
                mode === 'spread' 
                  ? 'from-purple-500/20 to-pink-500/20 border-purple-400/30' 
                  : 'from-emerald-500/20 to-cyan-500/20 border-emerald-400/30'
              }`}>
                <div className="flex items-center gap-2 mb-2">
                  <i data-lucide="check-circle" className={`w-5 h-5 ${mode === 'spread' ? 'text-purple-300' : 'text-emerald-300'}`}></i>
                  <h4 className="text-white/90 font-semibold">✅ Stego Image Ready!</h4>
                </div>
                <p className="text-sm text-white/80 mb-2">
                  Your message is now hidden inside the image using <strong>{mode === 'spread' ? 'Spread Spectrum' : 'LSB'}</strong> encoding.
                </p>
                
                {mode === 'spread' ? (
                  <div className="space-y-2">
                    <div className="p-2 rounded-lg bg-purple-500/20 border border-purple-400/30">
                      <p className="text-xs text-purple-100 font-semibold mb-1">🛡️ Compression-Resistant Mode Active</p>
                      <p className="text-xs text-white/70">This image can survive JPEG compression! Safe to share on:</p>
                      <div className="flex flex-wrap gap-2 mt-2">
                        <span className="px-2 py-1 rounded-lg bg-emerald-500/20 border border-emerald-400/30 text-xs">✅ Twitter/X</span>
                        <span className="px-2 py-1 rounded-lg bg-emerald-500/20 border border-emerald-400/30 text-xs">✅ Instagram</span>
                        <span className="px-2 py-1 rounded-lg bg-emerald-500/20 border border-emerald-400/30 text-xs">✅ Facebook</span>
                        <span className="px-2 py-1 rounded-lg bg-emerald-500/20 border border-emerald-400/30 text-xs">✅ WhatsApp</span>
                        <span className="px-2 py-1 rounded-lg bg-emerald-500/20 border border-emerald-400/30 text-xs">✅ Email</span>
                      </div>
                    </div>
                    <p className="text-xs text-white/60">
                      ⚠️ Don't forget to share the password separately via a secure channel!
                    </p>
                  </div>
                ) : (
                  <div className="space-y-2">
                    <div className="flex flex-wrap gap-2 text-xs">
                      <span className="px-3 py-1 rounded-lg bg-white/10 border border-white/20">📧 Email</span>
                      <span className="px-3 py-1 rounded-lg bg-white/10 border border-white/20">💬 WhatsApp Doc</span>
                      <span className="px-3 py-1 rounded-lg bg-white/10 border border-white/20">📱 Telegram File</span>
                      <span className="px-3 py-1 rounded-lg bg-white/10 border border-white/20">💬 Discord</span>
                    </div>
                    <div className="p-3 rounded-lg bg-yellow-500/20 border border-yellow-400/30">
                      <div className="flex items-start gap-2">
                        <i data-lucide="alert-triangle" className="w-4 h-4 text-yellow-300 shrink-0 mt-0.5"></i>
                        <div className="text-xs text-yellow-100">
                          <strong>LSB Mode:</strong> Send as <strong>uncompressed PNG</strong>. Don't post on X/Instagram as photo. Use <strong>Spread Spectrum mode</strong> for social media posting.
                        </div>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>
        </GlassCard>
      );
    }
    
    function StegoReceiver({ pushToast }) {
      const [extractedMessage, setExtractedMessage] = useState("");
      const [extracting, setExtracting] = useState(false);
      const [mode, setMode] = useState('auto'); // 'auto', 'lsb', or 'spread'
      const imageFileRef = useRef(null);
      
      useEffect(()=>{
        if(window.lucide) window.lucide.createIcons();
      });
      
      async function extractMessage() {
        if (!imageFileRef.current?.files?.[0]) {
          pushToast("Select an image first", "err");
          return;
        }
        
        setExtracting(true);
        try {
          const imageFile = imageFileRef.current.files[0];
          let extracted = null;
          
          // Auto mode: Try both methods with empty password
          if (mode === 'auto') {
            // Try LSB first (faster)
            try {
              extracted = await extractDataFromImage(imageFile);
              pushToast("✓ Message extracted (LSB mode)!", "ok");
            } catch (lsbError) {
              // LSB failed, try Spread Spectrum with empty password
              try {
                extracted = await spreadSpectrumDecode(imageFile, '');
                pushToast("✓ Message extracted (Spread Spectrum mode)!", "ok");
              } catch (spreadError) {
                throw new Error("No hidden message found. Make sure this image was created with Whistle's steganography feature.");
              }
            }
          } else if (mode === 'spread') {
            extracted = await spreadSpectrumDecode(imageFile, '');
            pushToast("✓ Message extracted (Spread Spectrum)!", "ok");
          } else {
            extracted = await extractDataFromImage(imageFile);
            pushToast("✓ Message extracted (LSB)!", "ok");
          }
          
          setExtractedMessage(extracted);
        } catch (e) {
          pushToast("Extraction failed: " + e.message, "err");
          setExtractedMessage("");
        }
        setExtracting(false);
      }
      
      async function copyMessage() {
        try {
          await navigator.clipboard.writeText(extractedMessage);
          pushToast("Message copied", "ok");
        } catch (e) {
          pushToast("Copy failed", "err");
        }
      }
      
      function resetStegoReceiver() {
        setExtractedMessage("");
        if (imageFileRef.current) imageFileRef.current.value = "";
        pushToast("Reset", "ok");
      }
      
      return (
        <GlassCard title="🎭 Steganography — Receiver" subtitle="Extract hidden messages from images">
          <div className="space-y-4">
            {/* Mode Selection */}
            <div className="p-3 rounded-xl bg-gradient-to-r from-cyan-500/10 to-purple-500/10 border border-cyan-400/20">
              <label className="text-sm text-white/80 font-semibold mb-2 block">Decoding Mode</label>
              <div className="grid grid-cols-3 gap-2">
                <button 
                  onClick={(e)=>{ ripple(e); setMode('auto'); }}
                  className={`rounded-xl p-2 border transition-all btn-ripple ${mode === 'auto' ? 'bg-cyan-500/30 border-cyan-400/50 text-white' : 'bg-white/[0.04] border-white/10 text-white/70 hover:bg-white/[0.08]'}`}
                >
                  <div className="flex items-center justify-center gap-1 mb-1">
                    <i data-lucide="wand-2" className="w-4 h-4"></i>
                    <span className="font-semibold text-xs">Auto</span>
                  </div>
                  <p className="text-[10px] opacity-80">Tries both</p>
                </button>
                <button 
                  onClick={(e)=>{ ripple(e); setMode('lsb'); }}
                  className={`rounded-xl p-2 border transition-all btn-ripple ${mode === 'lsb' ? 'bg-cyan-500/30 border-cyan-400/50 text-white' : 'bg-white/[0.04] border-white/10 text-white/70 hover:bg-white/[0.08]'}`}
                >
                  <div className="flex items-center justify-center gap-1 mb-1">
                    <i data-lucide="zap" className="w-4 h-4"></i>
                    <span className="font-semibold text-xs">LSB</span>
                  </div>
                  <p className="text-[10px] opacity-80">Fast</p>
                </button>
                <button 
                  onClick={(e)=>{ ripple(e); setMode('spread'); }}
                  className={`rounded-xl p-2 border transition-all btn-ripple ${mode === 'spread' ? 'bg-purple-500/30 border-purple-400/50 text-white' : 'bg-white/[0.04] border-white/10 text-white/70 hover:bg-white/[0.08]'}`}
                >
                  <div className="flex items-center justify-center gap-1 mb-1">
                    <i data-lucide="shield" className="w-4 h-4"></i>
                    <span className="font-semibold text-xs">Spread</span>
                  </div>
                  <p className="text-[10px] opacity-80">Robust</p>
                </button>
              </div>
              <p className="text-xs text-white/60 mt-2">
                💡 <strong>Auto mode</strong> automatically detects the encoding method used.
              </p>
            </div>
            
            <div>
              <label className="text-sm text-white/80 font-semibold mb-2 block">Upload Image with Hidden Message</label>
              <input 
                ref={imageFileRef} 
                type="file" 
                accept="image/*" 
                onChange={() => setExtractedMessage("")}
                className="w-full rounded-xl bg-white/[0.06] border border-white/10 p-3 text-sm file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-purple-500/30 file:text-purple-100 hover:file:bg-purple-500/40"
              />
              <p className="text-xs text-white/50 mt-1">Select the image you received from the sender.</p>
            </div>
            
            <div className="flex gap-3">
              <button 
                onClick={(e)=>{ ripple(e); extractMessage(); }} 
                disabled={extracting}
                className="flex items-center gap-2 rounded-xl bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-400 hover:to-pink-400 disabled:opacity-50 text-white font-semibold px-6 py-3 btn-ripple btn-press shadow-lg"
              >
                <i data-lucide={extracting ? "loader" : "scan"} className={`w-5 h-5 ${extracting ? 'animate-spin' : ''}`}></i>
                {extracting ? "Extracting..." : "Extract Message"}
              </button>
              
              {extractedMessage && (
                <button 
                  onClick={(e)=>{ ripple(e); copyMessage(); }}
                  className="flex items-center gap-2 rounded-xl bg-cyan-500/80 hover:bg-cyan-400 text-white font-semibold px-6 py-3 btn-ripple btn-press"
                >
                  <i data-lucide="copy" className="w-5 h-5"></i>
                  Copy Message
                </button>
              )}
              
              <button 
                onClick={(e)=>{ ripple(e); resetStegoReceiver(); }}
                className="flex items-center gap-2 rounded-xl bg-white/10 hover:bg-white/20 text-white font-semibold px-4 py-3 border border-white/10 btn-ripple btn-press"
              >
                <i data-lucide="refresh-cw" className="w-4 h-4"></i>
                Reset
              </button>
            </div>
            
            {extractedMessage && (
              <div className="mt-4 scale-in">
                <label className="text-sm text-white/80 font-semibold mb-2 block flex items-center gap-2">
                  <i data-lucide="lock-open" className="w-4 h-4 text-emerald-400"></i>
                  Extracted Message
                </label>
                <div className="rounded-xl bg-emerald-500/10 border border-emerald-400/30 p-4">
                  <pre className="whitespace-pre-wrap text-sm text-white/90 font-mono">{extractedMessage}</pre>
                </div>
                <p className="text-xs text-white/60 mt-2">
                  ✅ Message successfully extracted from the image!
                </p>
              </div>
            )}
            
            {!extractedMessage && !extracting && (
              <div className="p-4 rounded-xl bg-purple-500/10 border border-purple-400/20">
                <div className="flex items-center gap-2 mb-2">
                  <i data-lucide="info" className="w-4 h-4 text-purple-300"></i>
                  <h4 className="text-white/90 font-semibold text-sm">How it works</h4>
                </div>
                <ul className="text-xs text-white/70 space-y-1 list-disc list-inside">
                  <li>Sender hides a message inside a normal-looking image</li>
                  <li>The image looks 100% innocent to anyone else</li>
                  <li>You upload that image here to reveal the hidden message</li>
                  <li>Perfect for covert communication!</li>
                </ul>
              </div>
            )}
          </div>
        </GlassCard>
      );
    }
    
    // ===== WRAPPER COMPONENTS WITH TABS =====
    
    function WebRTCTransfer({ pushToast, onHashReady, setVerifyHash }) {
      const [mode, setMode] = useState('send');
      
      useEffect(()=>{
        if(window.lucide) window.lucide.createIcons();
      },[mode]);
      
      return (
        <div className="space-y-4">
          <div className="flex gap-2 p-1 rounded-xl bg-white/[0.04] border border-white/10 w-fit">
            <button
              onClick={() => setMode('send')}
              className={`px-6 py-2 rounded-lg font-semibold text-sm transition-all ${
                mode === 'send'
                  ? 'bg-cyan-500/30 text-cyan-100 border border-cyan-400/50'
                  : 'text-white/70 hover:text-white/90'
              }`}
            >
              <div className="flex items-center gap-2">
                <i data-lucide="send" className="w-4 h-4"></i>
                Sender
              </div>
            </button>
            <button
              onClick={() => setMode('receive')}
              className={`px-6 py-2 rounded-lg font-semibold text-sm transition-all ${
                mode === 'receive'
                  ? 'bg-purple-500/30 text-purple-100 border border-purple-400/50'
                  : 'text-white/70 hover:text-white/90'
              }`}
            >
              <div className="flex items-center gap-2">
                <i data-lucide="download" className="w-4 h-4"></i>
                Receiver
              </div>
            </button>
          </div>
          
          {mode === 'send' && <Sender pushToast={pushToast} onHashReady={onHashReady} />}
          {mode === 'receive' && <Receiver pushToast={pushToast} onHashReady={onHashReady} setVerifyHash={setVerifyHash} />}
        </div>
      );
    }
    
    function ImageStego({ pushToast }) {
      const [mode, setMode] = useState('send');
      
      useEffect(()=>{
        if(window.lucide) window.lucide.createIcons();
      },[mode]);
      
      return (
        <div className="space-y-4">
          <div className="flex gap-2 p-1 rounded-xl bg-white/[0.04] border border-white/10 w-fit">
            <button
              onClick={() => setMode('send')}
              className={`px-6 py-2 rounded-lg font-semibold text-sm transition-all ${
                mode === 'send'
                  ? 'bg-purple-500/30 text-purple-100 border border-purple-400/50'
                  : 'text-white/70 hover:text-white/90'
              }`}
            >
              <div className="flex items-center gap-2">
                <i data-lucide="image" className="w-4 h-4"></i>
                Hide in Image
              </div>
            </button>
            <button
              onClick={() => setMode('receive')}
              className={`px-6 py-2 rounded-lg font-semibold text-sm transition-all ${
                mode === 'receive'
                  ? 'bg-cyan-500/30 text-cyan-100 border border-cyan-400/50'
                  : 'text-white/70 hover:text-white/90'
              }`}
            >
              <div className="flex items-center gap-2">
                <i data-lucide="scan" className="w-4 h-4"></i>
                Extract from Image
              </div>
            </button>
          </div>
          
          {mode === 'send' && <StegoSender pushToast={pushToast} />}
          {mode === 'receive' && <StegoReceiver pushToast={pushToast} />}
        </div>
      );
    }
    
    function AudioStego({ pushToast }) {
      const [mode, setMode] = useState('send');
      
      useEffect(()=>{
        if(window.lucide) window.lucide.createIcons();
      },[mode]);
      
      return (
        <div className="space-y-4">
          <div className="flex gap-2 p-1 rounded-xl bg-white/[0.04] border border-white/10 w-fit">
            <button
              onClick={() => setMode('send')}
              className={`px-6 py-2 rounded-lg font-semibold text-sm transition-all ${
                mode === 'send'
                  ? 'bg-pink-500/30 text-pink-100 border border-pink-400/50'
                  : 'text-white/70 hover:text-white/90'
              }`}
            >
              <div className="flex items-center gap-2">
                <i data-lucide="music" className="w-4 h-4"></i>
                Hide in Audio
              </div>
            </button>
            <button
              onClick={() => setMode('receive')}
              className={`px-6 py-2 rounded-lg font-semibold text-sm transition-all ${
                mode === 'receive'
                  ? 'bg-cyan-500/30 text-cyan-100 border border-cyan-400/50'
                  : 'text-white/70 hover:text-white/90'
              }`}
            >
              <div className="flex items-center gap-2">
                <i data-lucide="headphones" className="w-4 h-4"></i>
                Extract from Audio
              </div>
            </button>
          </div>
          
          {mode === 'send' && <AudioStegoSender pushToast={pushToast} />}
          {mode === 'receive' && <AudioStegoReceiver pushToast={pushToast} />}
        </div>
      );
    }
    
    function VideoStego({ pushToast }) {
      const [mode, setMode] = useState('send');
      
      useEffect(()=>{
        if(window.lucide) window.lucide.createIcons();
      },[mode]);
      
      return (
        <div className="space-y-4">
          <div className="flex gap-2 p-1 rounded-xl bg-white/[0.04] border border-white/10 w-fit">
            <button
              onClick={() => setMode('send')}
              className={`px-6 py-2 rounded-lg font-semibold text-sm transition-all ${
                mode === 'send'
                  ? 'bg-violet-500/30 text-violet-100 border border-violet-400/50'
                  : 'text-white/70 hover:text-white/90'
              }`}
            >
              <div className="flex items-center gap-2">
                <i data-lucide="video" className="w-4 h-4"></i>
                Hide in Video
              </div>
            </button>
            <button
              onClick={() => setMode('receive')}
              className={`px-6 py-2 rounded-lg font-semibold text-sm transition-all ${
                mode === 'receive'
                  ? 'bg-cyan-500/30 text-cyan-100 border border-cyan-400/50'
                  : 'text-white/70 hover:text-white/90'
              }`}
            >
              <div className="flex items-center gap-2">
                <i data-lucide="film" className="w-4 h-4"></i>
                Extract from Video
              </div>
            </button>
          </div>
          
          {mode === 'send' && <VideoStegoSender pushToast={pushToast} />}
          {mode === 'receive' && <VideoStegoReceiver pushToast={pushToast} />}
        </div>
      );
    }
    
    // ===== AUDIO STEGANOGRAPHY COMPONENTS =====
    
    function AudioStegoSender({ pushToast }) {
      const [message, setMessage] = useState("");
      const [stegoAudio, setStegoAudio] = useState(null);
      const [processing, setProcessing] = useState(false);
      const audioFileRef = useRef(null);
      
      useEffect(()=>{
        if(window.lucide) window.lucide.createIcons();
      },[]);
      
      async function createStegoAudio() {
        if (!message.trim()) {
          pushToast("Write a message first", "err");
          return;
        }
        if (!audioFileRef.current?.files?.[0]) {
          pushToast("Select an audio file", "err");
          return;
        }
        
        setProcessing(true);
        try {
          const audioFile = audioFileRef.current.files[0];
          const hiddenAudio = await hideDataInAudio(audioFile, message);
          setStegoAudio(hiddenAudio);
          pushToast("✓ Message hidden in audio!", "ok");
        } catch (e) {
          pushToast("Failed: " + e.message, "err");
        }
        setProcessing(false);
      }
      
      function downloadAudio() {
        if (!stegoAudio) return;
        const url = URL.createObjectURL(stegoAudio);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'audio_message.wav';
        a.click();
        URL.revokeObjectURL(url);
        pushToast("Audio downloaded!", "ok");
      }
      
      function resetAudioSender() {
        setMessage("");
        setStegoAudio(null);
        if (audioFileRef.current) audioFileRef.current.value = "";
        pushToast("Reset", "ok");
      }
      
      return (
        <GlassCard title="🎵 Audio Steganography — Sender" subtitle="Hide messages inside audio files (WAV, MP3)">
          <div className="space-y-4">
            <div className="p-3 rounded-xl bg-gradient-to-r from-pink-500/10 to-rose-500/10 border border-pink-400/20">
              <div className="flex items-center gap-2 mb-2">
                <i data-lucide="music" className="w-5 h-5 text-pink-400"></i>
                <h4 className="text-white/90 font-semibold text-sm">Share via Voice Memos</h4>
              </div>
              <p className="text-xs text-white/70">
                Hide secret messages in audio files. Perfect for sharing through SoundCloud, voice messages, or podcast uploads.
                The audio sounds completely normal!
              </p>
            </div>
            
            <div>
              <label className="text-sm text-white/80 font-semibold mb-2 block">Your Secret Message</label>
              <textarea 
                value={message} 
                onChange={(e) => setMessage(e.target.value)} 
                rows={4} 
                className="w-full rounded-xl bg-white/[0.06] border border-white/10 p-3 outline-none focus:ring-2 focus:ring-pink-400/40 text-white" 
                placeholder="Type your confidential message here..."
              />
              <p className="text-xs text-white/50 mt-1">
                Message will be encoded into audio samples. Limit: ~10,000 characters for a 1-minute audio.
              </p>
            </div>
            
            <div>
              <label className="text-sm text-white/80 font-semibold mb-2 block">Cover Audio File</label>
              <input 
                ref={audioFileRef} 
                type="file" 
                accept="audio/*" 
                className="w-full rounded-xl bg-white/[0.06] border border-white/10 p-3 text-sm file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-pink-500/30 file:text-pink-100 hover:file:bg-pink-500/40"
              />
              <p className="text-xs text-white/50 mt-1">
                Choose any audio: music, voice memo, podcast clip, ambient sound, etc.
              </p>
            </div>
            
            <div className="flex gap-3 flex-wrap">
              <button 
                onClick={(e)=>{ ripple(e); createStegoAudio(); }} 
                disabled={processing}
                className="flex items-center gap-2 rounded-xl bg-gradient-to-r from-pink-500 to-rose-500 hover:from-pink-400 hover:to-rose-400 disabled:opacity-50 text-white font-semibold px-6 py-3 btn-ripple btn-press shadow-lg"
              >
                <i data-lucide={processing ? "loader" : "wand-2"} className={`w-5 h-5 ${processing ? 'animate-spin' : ''}`}></i>
                {processing ? "Hiding Message..." : "Create Stego Audio"}
              </button>
              
              {stegoAudio && (
                <>
                  <button 
                    onClick={(e)=>{ ripple(e); downloadAudio(); }}
                    className="flex items-center gap-2 rounded-xl bg-emerald-500/30 hover:bg-emerald-400/40 text-emerald-100 font-semibold px-6 py-3 btn-ripple btn-press shadow-lg border border-emerald-400/30"
                  >
                    <i data-lucide="download" className="w-5 h-5"></i>
                    Download Audio
                  </button>
                  <button 
                    onClick={(e)=>{ ripple(e); resetAudioSender(); }}
                    className="flex items-center gap-2 rounded-xl bg-white/10 hover:bg-white/20 text-white font-semibold px-6 py-3 btn-ripple btn-press border border-white/10"
                  >
                    <i data-lucide="refresh-cw" className="w-5 h-5"></i>
                    Reset
                  </button>
                </>
              )}
            </div>
            
            {stegoAudio && (
              <div className="p-3 rounded-xl bg-emerald-500/20 border border-emerald-400/30">
                <div className="flex items-center gap-2 mb-2">
                  <i data-lucide="check-circle" className="w-5 h-5 text-emerald-300"></i>
                  <h4 className="text-white/90 font-semibold text-sm">Ready to Share!</h4>
                </div>
                <p className="text-xs text-white/70 mb-2">
                  Your message is now hidden in the audio file. Share it via:
                </p>
                <div className="flex flex-wrap gap-2">
                  <span className="px-3 py-1 rounded-lg bg-white/10 border border-white/20 text-xs">💬 WhatsApp Voice</span>
                  <span className="px-3 py-1 rounded-lg bg-white/10 border border-white/20 text-xs">🎵 SoundCloud</span>
                  <span className="px-3 py-1 rounded-lg bg-white/10 border border-white/20 text-xs">📧 Email</span>
                  <span className="px-3 py-1 rounded-lg bg-white/10 border border-white/20 text-xs">🎙️ Podcast</span>
                  <span className="px-3 py-1 rounded-lg bg-white/10 border border-white/20 text-xs">☁️ Dropbox</span>
                </div>
              </div>
            )}
          </div>
        </GlassCard>
      );
    }
    
    function AudioStegoReceiver({ pushToast }) {
      const [extractedMessage, setExtractedMessage] = useState("");
      const [extracting, setExtracting] = useState(false);
      const audioFileRef = useRef(null);
      
      useEffect(()=>{
        if(window.lucide) window.lucide.createIcons();
      },[]);
      
      async function extractMessage() {
        if (!audioFileRef.current?.files?.[0]) {
          pushToast("Select an audio file first", "err");
          return;
        }
        
        setExtracting(true);
        try {
          const audioFile = audioFileRef.current.files[0];
          const message = await extractDataFromAudio(audioFile);
          setExtractedMessage(message);
          pushToast("✓ Message extracted from audio!", "ok");
        } catch (e) {
          pushToast("Extraction failed: " + e.message, "err");
          setExtractedMessage("");
        }
        setExtracting(false);
      }
      
      async function copyMessage() {
        try {
          await navigator.clipboard.writeText(extractedMessage);
          pushToast("Message copied", "ok");
        } catch (e) {
          pushToast("Copy failed", "err");
        }
      }
      
      function resetAudioReceiver() {
        setExtractedMessage("");
        if (audioFileRef.current) audioFileRef.current.value = "";
        pushToast("Reset", "ok");
      }
      
      return (
        <GlassCard title="🎵 Audio Steganography — Receiver" subtitle="Extract hidden messages from audio files">
          <div className="space-y-4">
            <div className="p-3 rounded-xl bg-gradient-to-r from-pink-500/10 to-rose-500/10 border border-pink-400/20">
              <div className="flex items-center gap-2 mb-2">
                <i data-lucide="headphones" className="w-5 h-5 text-pink-400"></i>
                <h4 className="text-white/90 font-semibold text-sm">Decode Audio Messages</h4>
              </div>
              <p className="text-xs text-white/70">
                Upload an audio file that contains a hidden message to reveal the secret text.
              </p>
            </div>
            
            <div>
              <label className="text-sm text-white/80 font-semibold mb-2 block">Upload Audio with Hidden Message</label>
              <input 
                ref={audioFileRef} 
                type="file" 
                accept="audio/*" 
                className="w-full rounded-xl bg-white/[0.06] border border-white/10 p-3 text-sm file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-pink-500/30 file:text-pink-100 hover:file:bg-pink-500/40"
              />
              <p className="text-xs text-white/50 mt-1">
                Supports WAV, MP3, M4A, and other audio formats.
              </p>
            </div>
            
            <div className="flex gap-3 flex-wrap">
              <button 
                onClick={(e)=>{ ripple(e); extractMessage(); }} 
                disabled={extracting}
                className="flex items-center gap-2 rounded-xl bg-gradient-to-r from-pink-500 to-rose-500 hover:from-pink-400 hover:to-rose-400 disabled:opacity-50 text-white font-semibold px-6 py-3 btn-ripple btn-press shadow-lg"
              >
                <i data-lucide={extracting ? "loader" : "unlock"} className={`w-5 h-5 ${extracting ? 'animate-spin' : ''}`}></i>
                {extracting ? "Extracting..." : "Extract Message"}
              </button>
              
              {extractedMessage && (
                <>
                  <button 
                    onClick={(e)=>{ ripple(e); copyMessage(); }}
                    className="flex items-center gap-2 rounded-xl bg-cyan-500/30 hover:bg-cyan-400/40 text-cyan-100 font-semibold px-6 py-3 btn-ripple btn-press border border-cyan-400/30"
                  >
                    <i data-lucide="copy" className="w-5 h-5"></i>
                    Copy Message
                  </button>
                  <button 
                    onClick={(e)=>{ ripple(e); resetAudioReceiver(); }}
                    className="flex items-center gap-2 rounded-xl bg-white/10 hover:bg-white/20 text-white font-semibold px-6 py-3 btn-ripple btn-press border border-white/10"
                  >
                    <i data-lucide="refresh-cw" className="w-5 h-5"></i>
                    Reset
                  </button>
                </>
              )}
            </div>
            
            {extractedMessage && (
              <div className="p-3 rounded-xl bg-emerald-500/20 border border-emerald-400/30">
                <div className="flex items-center gap-2 mb-2">
                  <i data-lucide="check-circle" className="w-5 h-5 text-emerald-300"></i>
                  <h4 className="text-white/90 font-semibold text-sm">Hidden Message Revealed</h4>
                </div>
                <div className="mt-2 p-3 rounded-lg bg-black/30 border border-white/10">
                  <pre className="text-sm text-white/90 whitespace-pre-wrap font-mono">{extractedMessage}</pre>
                </div>
              </div>
            )}
          </div>
        </GlassCard>
      );
    }
    
    // ===== VIDEO STEGANOGRAPHY COMPONENTS =====
    
    function VideoStegoSender({ pushToast }) {
      const [message, setMessage] = useState("");
      const [stegoVideo, setStegoVideo] = useState(null);
      const [processing, setProcessing] = useState(false);
      const videoFileRef = useRef(null);
      
      useEffect(()=>{
        if(window.lucide) window.lucide.createIcons();
      },[]);
      
      async function createStegoVideo() {
        if (!message.trim()) {
          pushToast("Write a message first", "err");
          return;
        }
        if (!videoFileRef.current?.files?.[0]) {
          pushToast("Select a video file", "err");
          return;
        }
        
        setProcessing(true);
        try {
          const videoFile = videoFileRef.current.files[0];
          const hiddenVideo = await hideDataInVideo(videoFile, message);
          setStegoVideo(hiddenVideo);
          pushToast("✓ Message hidden in video!", "ok");
        } catch (e) {
          pushToast("Failed: " + e.message, "err");
        }
        setProcessing(false);
      }
      
      function downloadVideo() {
        if (!stegoVideo) return;
        const url = URL.createObjectURL(stegoVideo);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'video_message.webm';
        a.click();
        URL.revokeObjectURL(url);
        pushToast("Video downloaded!", "ok");
      }
      
      function resetVideoSender() {
        setMessage("");
        setStegoVideo(null);
        if (videoFileRef.current) videoFileRef.current.value = "";
        pushToast("Reset", "ok");
      }
      
      return (
        <GlassCard title="🎥 Video Steganography — Sender" subtitle="Hide messages across video frames">
          <div className="space-y-4">
            <div className="p-3 rounded-xl bg-gradient-to-r from-violet-500/10 to-purple-500/10 border border-violet-400/20">
              <div className="flex items-center gap-2 mb-2">
                <i data-lucide="video" className="w-5 h-5 text-violet-400"></i>
                <h4 className="text-white/90 font-semibold text-sm">Share on Social Media</h4>
              </div>
              <p className="text-xs text-white/70">
                Hide secret messages distributed across video frames. Share on YouTube, TikTok, Instagram Reels.
                The video looks completely normal!
              </p>
            </div>
            
            <div>
              <label className="text-sm text-white/80 font-semibold mb-2 block">Your Secret Message</label>
              <textarea 
                value={message} 
                onChange={(e) => setMessage(e.target.value)} 
                rows={4} 
                className="w-full rounded-xl bg-white/[0.06] border border-white/10 p-3 outline-none focus:ring-2 focus:ring-violet-400/40 text-white" 
                placeholder="Type your confidential message here..."
              />
              <p className="text-xs text-white/50 mt-1">
                Message will be distributed across video frames. Limit: ~1,000 characters per 10-second video.
              </p>
            </div>
            
            <div>
              <label className="text-sm text-white/80 font-semibold mb-2 block">Cover Video File</label>
              <input 
                ref={videoFileRef} 
                type="file" 
                accept="video/*" 
                className="w-full rounded-xl bg-white/[0.06] border border-white/10 p-3 text-sm file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-violet-500/30 file:text-violet-100 hover:file:bg-violet-500/40"
              />
              <p className="text-xs text-white/50 mt-1">
                Choose any video: vacation clip, pet video, screen recording, vlog, etc.
              </p>
            </div>
            
            <div className="flex gap-3 flex-wrap">
              <button 
                onClick={(e)=>{ ripple(e); createStegoVideo(); }} 
                disabled={processing}
                className="flex items-center gap-2 rounded-xl bg-gradient-to-r from-violet-500 to-purple-500 hover:from-violet-400 hover:to-purple-400 disabled:opacity-50 text-white font-semibold px-6 py-3 btn-ripple btn-press shadow-lg"
              >
                <i data-lucide={processing ? "loader" : "wand-2"} className={`w-5 h-5 ${processing ? 'animate-spin' : ''}`}></i>
                {processing ? "Processing Video..." : "Create Stego Video"}
              </button>
              
              {stegoVideo && (
                <>
                  <button 
                    onClick={(e)=>{ ripple(e); downloadVideo(); }}
                    className="flex items-center gap-2 rounded-xl bg-emerald-500/30 hover:bg-emerald-400/40 text-emerald-100 font-semibold px-6 py-3 btn-ripple btn-press shadow-lg border border-emerald-400/30"
                  >
                    <i data-lucide="download" className="w-5 h-5"></i>
                    Download Video
                  </button>
                  <button 
                    onClick={(e)=>{ ripple(e); resetVideoSender(); }}
                    className="flex items-center gap-2 rounded-xl bg-white/10 hover:bg-white/20 text-white font-semibold px-6 py-3 btn-ripple btn-press border border-white/10"
                  >
                    <i data-lucide="refresh-cw" className="w-5 h-5"></i>
                    Reset
                  </button>
                </>
              )}
            </div>
            
            {processing && (
              <div className="p-3 rounded-xl bg-yellow-500/20 border border-yellow-400/30">
                <div className="flex items-center gap-2">
                  <i data-lucide="loader" className="w-5 h-5 text-yellow-300 animate-spin"></i>
                  <p className="text-sm text-yellow-100">
                    Processing video frames... This may take a minute for longer videos.
                  </p>
                </div>
              </div>
            )}
            
            {stegoVideo && (
              <div className="p-3 rounded-xl bg-emerald-500/20 border border-emerald-400/30">
                <div className="flex items-center gap-2 mb-2">
                  <i data-lucide="check-circle" className="w-5 h-5 text-emerald-300"></i>
                  <h4 className="text-white/90 font-semibold text-sm">Ready to Upload!</h4>
                </div>
                <p className="text-xs text-white/70 mb-2">
                  Your message is now hidden across the video frames. Share it via:
                </p>
                <div className="flex flex-wrap gap-2">
                  <span className="px-3 py-1 rounded-lg bg-white/10 border border-white/20 text-xs">📹 YouTube</span>
                  <span className="px-3 py-1 rounded-lg bg-white/10 border border-white/20 text-xs">🎵 TikTok</span>
                  <span className="px-3 py-1 rounded-lg bg-white/10 border border-white/20 text-xs">📷 Instagram Reels</span>
                  <span className="px-3 py-1 rounded-lg bg-white/10 border border-white/20 text-xs">💬 WhatsApp</span>
                  <span className="px-3 py-1 rounded-lg bg-white/10 border border-white/20 text-xs">📧 Email</span>
                </div>
              </div>
            )}
          </div>
        </GlassCard>
      );
    }
    
    function VideoStegoReceiver({ pushToast }) {
      const [extractedMessage, setExtractedMessage] = useState("");
      const [extracting, setExtracting] = useState(false);
      const videoFileRef = useRef(null);
      
      useEffect(()=>{
        if(window.lucide) window.lucide.createIcons();
      },[]);
      
      async function extractMessage() {
        if (!videoFileRef.current?.files?.[0]) {
          pushToast("Select a video file first", "err");
          return;
        }
        
        setExtracting(true);
        try {
          const videoFile = videoFileRef.current.files[0];
          const message = await extractDataFromVideo(videoFile);
          setExtractedMessage(message);
          pushToast("✓ Message extracted from video!", "ok");
        } catch (e) {
          pushToast("Extraction failed: " + e.message, "err");
          setExtractedMessage("");
        }
        setExtracting(false);
      }
      
      async function copyMessage() {
        try {
          await navigator.clipboard.writeText(extractedMessage);
          pushToast("Message copied", "ok");
        } catch (e) {
          pushToast("Copy failed", "err");
        }
      }
      
      function resetVideoReceiver() {
        setExtractedMessage("");
        if (videoFileRef.current) videoFileRef.current.value = "";
        pushToast("Reset", "ok");
      }
      
      return (
        <GlassCard title="🎥 Video Steganography — Receiver" subtitle="Extract hidden messages from videos">
          <div className="space-y-4">
            <div className="p-3 rounded-xl bg-gradient-to-r from-violet-500/10 to-purple-500/10 border border-violet-400/20">
              <div className="flex items-center gap-2 mb-2">
                <i data-lucide="film" className="w-5 h-5 text-violet-400"></i>
                <h4 className="text-white/90 font-semibold text-sm">Decode Video Messages</h4>
              </div>
              <p className="text-xs text-white/70">
                Upload a video file that contains a hidden message distributed across its frames.
              </p>
            </div>
            
            <div>
              <label className="text-sm text-white/80 font-semibold mb-2 block">Upload Video with Hidden Message</label>
              <input 
                ref={videoFileRef} 
                type="file" 
                accept="video/*" 
                className="w-full rounded-xl bg-white/[0.06] border border-white/10 p-3 text-sm file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-violet-500/30 file:text-violet-100 hover:file:bg-violet-500/40"
              />
              <p className="text-xs text-white/50 mt-1">
                Supports MP4, WebM, MOV, and other video formats.
              </p>
            </div>
            
            <div className="flex gap-3 flex-wrap">
              <button 
                onClick={(e)=>{ ripple(e); extractMessage(); }} 
                disabled={extracting}
                className="flex items-center gap-2 rounded-xl bg-gradient-to-r from-violet-500 to-purple-500 hover:from-violet-400 hover:to-purple-400 disabled:opacity-50 text-white font-semibold px-6 py-3 btn-ripple btn-press shadow-lg"
              >
                <i data-lucide={extracting ? "loader" : "unlock"} className={`w-5 h-5 ${extracting ? 'animate-spin' : ''}`}></i>
                {extracting ? "Extracting..." : "Extract Message"}
              </button>
              
              {extractedMessage && (
                <>
                  <button 
                    onClick={(e)=>{ ripple(e); copyMessage(); }}
                    className="flex items-center gap-2 rounded-xl bg-cyan-500/30 hover:bg-cyan-400/40 text-cyan-100 font-semibold px-6 py-3 btn-ripple btn-press border border-cyan-400/30"
                  >
                    <i data-lucide="copy" className="w-5 h-5"></i>
                    Copy Message
                  </button>
                  <button 
                    onClick={(e)=>{ ripple(e); resetVideoReceiver(); }}
                    className="flex items-center gap-2 rounded-xl bg-white/10 hover:bg-white/20 text-white font-semibold px-6 py-3 btn-ripple btn-press border border-white/10"
                  >
                    <i data-lucide="refresh-cw" className="w-5 h-5"></i>
                    Reset
                  </button>
                </>
              )}
            </div>
            
            {extracting && (
              <div className="p-3 rounded-xl bg-yellow-500/20 border border-yellow-400/30">
                <div className="flex items-center gap-2">
                  <i data-lucide="loader" className="w-5 h-5 text-yellow-300 animate-spin"></i>
                  <p className="text-sm text-yellow-100">
                    Scanning video frames... This may take a minute for longer videos.
                  </p>
                </div>
              </div>
            )}
            
            {extractedMessage && (
              <div className="p-3 rounded-xl bg-emerald-500/20 border border-emerald-400/30">
                <div className="flex items-center gap-2 mb-2">
                  <i data-lucide="check-circle" className="w-5 h-5 text-emerald-300"></i>
                  <h4 className="text-white/90 font-semibold text-sm">Hidden Message Revealed</h4>
                </div>
                <div className="mt-2 p-3 rounded-lg bg-black/30 border border-white/10">
                  <pre className="text-sm text-white/90 whitespace-pre-wrap font-mono">{extractedMessage}</pre>
                </div>
              </div>
            )}
          </div>
        </GlassCard>
      );
    }
    
    // ===== PRIVACY SWAP (4NON Widget Integration) =====
    
    function PrivacySwap() {
      useEffect(()=>{
        if(window.lucide) window.lucide.createIcons();
      },[]);
      
      return (
        <GlassCard title="Privacy Swap" subtitle="Anonymous cryptocurrency swaps powered by 4NON">
          <div className="space-y-4">
            <div className="p-3 rounded-xl bg-gradient-to-r from-green-500/10 to-emerald-500/10 border border-green-400/20">
              <div className="flex items-center gap-2 mb-2">
                <i data-lucide="shield-check" className="w-5 h-5 text-green-400"></i>
                <h4 className="text-white/90 font-semibold text-sm">Anonymous Swaps</h4>
              </div>
              <p className="text-xs text-white/70">
                Swap cryptocurrencies with complete privacy. No KYC, no tracking, no compromises.
                Powered by <a href="https://4nonswap.com" target="_blank" rel="noopener noreferrer" className="text-green-300 hover:text-green-200 underline">4NON</a>.
              </p>
            </div>
            
            <div className="flex justify-center">
              <div className="w-full max-w-[600px] rounded-2xl overflow-hidden border border-white/10 shadow-2xl">
                <iframe
                  src="https://4nonswap.com/widget?skin=dark"
                  style={{ width: '100%', height: '800px', border: 'none' }}
                  title="4NON Privacy Swap Widget"
                ></iframe>
              </div>
            </div>
            
            <div className="p-3 rounded-xl bg-cyan-500/10 border border-cyan-400/20">
              <div className="flex items-center gap-2 mb-2">
                <i data-lucide="info" className="w-4 h-4 text-cyan-400"></i>
                <h4 className="text-white/90 font-semibold text-xs">Privacy Tips</h4>
              </div>
              <ul className="text-xs text-white/70 space-y-1 list-disc list-inside">
                <li>Use Tor or VPN for maximum anonymity</li>
                <li>Avoid reusing addresses across multiple swaps</li>
                <li>For whistleblowing: swap to privacy coins (XMR, ZEC) before withdrawal</li>
                <li>Clear browser cache after completing swaps</li>
              </ul>
            </div>
          </div>
        </GlassCard>
      );
    }

    function App() {
      const { toasts, push } = useToasts();
      const [step, setStep] = usePersistentState('uiStep', "home");
      const [hashFromFlow, setHashFromFlow] = useState("");
      return (
        <div className="relative min-h-screen text-white">
          {/* animated gradient blobs */}
          <div className="sky"></div>
          <div className="sky-dim"></div>
          <div className="pointer-events-none absolute inset-0 -z-10 overflow-hidden">
            <div className="cloud c1"></div>
            <div className="cloud c2"></div>
            <div className="cloud c3"></div>
            <div className="cloud c4"></div>
            <div className="cloud c5"></div>
            <div className="cloud c6"></div>
            <div className="cloud c7"></div>
            <div className="cloud c8"></div>
            <div className="cloud c9"></div>
          </div>
          <div className="max-w-6xl mx-auto p-6 sm:p-4 md:p-6">
            <SectionHeader />
            <div className="mt-5 flex gap-6">
              <Sidebar step={step} setStep={setStep} />
              <main className="flex-1 min-w-0">
                <div className="mb-4 md:hidden">
                  <StepPills step={step} setStep={setStep} />
                </div>
                {step === 'home' && <Home setStep={setStep} />}
                {step === 'webrtc' && <WebRTCTransfer pushToast={push} onHashReady={setHashFromFlow} setVerifyHash={setHashFromFlow} />}
                {step === 'image-stego' && <ImageStego pushToast={push} />}
                {step === 'audio-stego' && <AudioStego pushToast={push} />}
                {step === 'video-stego' && <VideoStego pushToast={push} />}
                {step === 'swap' && <PrivacySwap />}
              </main>
            </div>
          </div>

          {/* Toasts */}
          <div className="fixed top-20 right-4 space-y-3 z-50">
            {toasts.map((t) => (
              <div key={t.id} className={`toast-enter rounded-2xl border-2 px-6 py-4 text-base font-semibold backdrop-blur-xl shadow-2xl min-w-[320px] ${
                t.tone === "ok"
                  ? "bg-emerald-500/90 border-emerald-300/50 text-white shadow-emerald-500/50"
                  : t.tone === "err"
                  ? "bg-rose-500/90 border-rose-300/50 text-white shadow-rose-500/50"
                  : "bg-cyan-500/90 border-cyan-300/50 text-white shadow-cyan-500/50"
              }`}>
                <div className="flex items-center gap-3">
                  {t.tone === "ok" && <i data-lucide="check-circle" className="w-6 h-6 shrink-0"></i>}
                  {t.tone === "err" && <i data-lucide="x-circle" className="w-6 h-6 shrink-0"></i>}
                  {t.tone !== "ok" && t.tone !== "err" && <i data-lucide="info" className="w-6 h-6 shrink-0"></i>}
                  <span className="flex-1">{t.msg}</span>
                </div>
              </div>
            ))}
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>
</body>
</html>


